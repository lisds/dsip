

<!DOCTYPE html>


<html lang="en" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Logistic regression &#8212; Data Science in Practice</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/styles/sphinx-book-theme.css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae" />
  <script src="_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=8d27b9dea8ad943066ae"></script>

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="application/vnd.jupyter.widget-state+json">{"state": {"883b1a98b9fe4dbe8a89a478aabe349c": {"model_name": "LayoutModel", "model_module": "@jupyter-widgets/base", "model_module_version": "2.0.0", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "2.0.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "2.0.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border_bottom": null, "border_left": null, "border_right": null, "border_top": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}, "e3b2b91e849a4395a766d4ec93bb7014": {"model_name": "VBoxModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "state": {"_dom_classes": ["widget-interact"], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "2.0.0", "_model_name": "VBoxModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "2.0.0", "_view_name": "VBoxView", "box_style": "", "children": ["IPY_MODEL_0949db0a464547279b55ee1005a4c6ad", "IPY_MODEL_30956a1a01094f7080f65c2e747898e5"], "layout": "IPY_MODEL_883b1a98b9fe4dbe8a89a478aabe349c", "tabbable": null, "tooltip": null}}, "ef96badf79704296bb1b35088337108e": {"model_name": "LayoutModel", "model_module": "@jupyter-widgets/base", "model_module_version": "2.0.0", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "2.0.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "2.0.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border_bottom": null, "border_left": null, "border_right": null, "border_top": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}, "4944ef5a073b45faab8e895c98646271": {"model_name": "SliderStyleModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "state": {"_model_module": "@jupyter-widgets/controls", "_model_module_version": "2.0.0", "_model_name": "SliderStyleModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "2.0.0", "_view_name": "StyleView", "description_width": "", "handle_color": null}}, "0949db0a464547279b55ee1005a4c6ad": {"model_name": "IntSliderModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "2.0.0", "_model_name": "IntSliderModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "2.0.0", "_view_name": "IntSliderView", "behavior": "drag-tap", "continuous_update": true, "description": "probability_percent", "description_allow_html": false, "disabled": false, "layout": "IPY_MODEL_ef96badf79704296bb1b35088337108e", "max": 99, "min": 0, "orientation": "horizontal", "readout": true, "readout_format": "d", "step": 1, "style": "IPY_MODEL_4944ef5a073b45faab8e895c98646271", "tabbable": null, "tooltip": null, "value": 50}}, "e1334b2b7dc142338d8beea582653e05": {"model_name": "LayoutModel", "model_module": "@jupyter-widgets/base", "model_module_version": "2.0.0", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "2.0.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "2.0.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border_bottom": null, "border_left": null, "border_right": null, "border_top": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}, "30956a1a01094f7080f65c2e747898e5": {"model_name": "OutputModel", "model_module": "@jupyter-widgets/output", "model_module_version": "1.0.0", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/output", "_model_module_version": "1.0.0", "_model_name": "OutputModel", "_view_count": null, "_view_module": "@jupyter-widgets/output", "_view_module_version": "1.0.0", "_view_name": "OutputView", "layout": "IPY_MODEL_e1334b2b7dc142338d8beea582653e05", "msg_id": "", "outputs": [{"output_type": "display_data", "metadata": {}, "data": {"text/plain": "<IPython.core.display.Markdown object>", "text/markdown": "If a probability of an event of interest is **50%**:"}}, {"output_type": "display_data", "metadata": {}, "data": {"text/plain": "<IPython.core.display.Markdown object>", "text/markdown": "$\\text{Prob(Event of Interest)} = \\frac{50}{100}$"}}, {"output_type": "display_data", "metadata": {}, "data": {"text/plain": "<IPython.core.display.Markdown object>", "text/markdown": "Then the odds of the event of interest are **1.0**"}}, {"output_type": "display_data", "metadata": {}, "data": {"text/plain": "<IPython.core.display.Markdown object>", "text/markdown": "$\\text{Odds(Event of Interest)} = \\frac{50}{50}$"}}], "tabbable": null, "tooltip": null}}}, "version_major": 2, "version_minor": 0}</script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script crossorigin="anonymous" data-jupyter-widgets-cdn="https://cdn.jsdelivr.net/npm/" src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@1.0.6/dist/embed-amd.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'logistic_regression';</script>
    <link rel="canonical" href="https://lisds.github.io/dsip/logistic_regression.html" />
    <link rel="shortcut icon" href="_static/dsfe_favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <header class="bd-header navbar navbar-expand-lg bd-navbar">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="_static/dsfe_logo.png" class="logo__image only-light" alt="Data Science in Practice - Home"/>
    <script>document.write(`<img src="_static/dsfe_logo.png" class="logo__image only-dark" alt="Data Science in Practice - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Coding background</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="assert.html">Using <code class="docutils literal notranslate"><span class="pre">assert</span></code> for testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="arrays_and_images.html">Arrays as images, images as arrays</a></li>
<li class="toctree-l1"><a class="reference internal" href="where_and_argmin.html">Where and argmin</a></li>
<li class="toctree-l1"><a class="reference internal" href="where_2d.html">Where in 2D</a></li>
<li class="toctree-l1"><a class="reference internal" href="image_for_optimize.html">2D arrays, images, optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="pathlib.html">Using the <code class="docutils literal notranslate"><span class="pre">pathlib</span></code> module</a></li>
<li class="toctree-l1"><a class="reference internal" href="dictionaries.html">Dictionaries</a></li>
<li class="toctree-l1"><a class="reference internal" href="pandas_and_dicts.html">Pandas and dictionaries</a></li>
<li class="toctree-l1"><a class="reference internal" href="lambda_functions.html">Lambda functions</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Reading formulae</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="on_vectors.html">Vectors and dot products</a></li>
<li class="toctree-l1"><a class="reference internal" href="numpy_and_vectors.html">Numpy, arrays, and vectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="algebra_of_sums.html">Some algebra with summation</a></li>
<li class="toctree-l1"><a class="reference internal" href="lin_regression_notation.html">Notation for linear regression models</a></li>
<li class="toctree-l1"><a class="reference internal" href="vector_projection.html">Vector projection</a></li>
<li class="toctree-l1"><a class="reference internal" href="pca_introduction.html">Introducing principal component analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="pca_dimension_reduction.html">Dimension reduction with Principal Component Analysis</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Intermediate regression</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="lin_regression_multiple_predictors.html">Linear regression notation for models with multiple predictors</a></li>
<li class="toctree-l1"><a class="reference internal" href="epl_modeling.html">Attack or defense?  An example of multiple regression</a></li>
<li class="toctree-l1"><a class="reference internal" href="linear_regression_categorical_predictors.html">Categorical predictors in linear regression</a></li>
<li class="toctree-l1"><a class="reference internal" href="multiple_predictors_statistical_adjustment.html">Statistical Adjustment in Multi-predictor Linear Regression Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="logistic_regression_cross_validation.html">Multiple Logistic Regression, Model Selection and Cross-validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="cost_functions.html">Fitting models with different cost functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_notation.html">Expressing the linear model with matrices</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Classification</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="naive_bayes.html">Naive Bayes classifiers</a></li>
<li class="toctree-l1"><a class="reference internal" href="k_means.html">k-means clustering</a></li>
<li class="toctree-l1"><a class="reference internal" href="kernel_density_estimation.html">Kernel density estimation</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Working with data</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="data_work.html">The problem with data</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">The tools</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installing on your computer</a></li>
<li class="toctree-l1"><a class="reference internal" href="the-problem-with-notebooks.html">The joys and sorrows of notebooks</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://mybinder.org/v2/gh/lisds/dsip/main?urlpath=lab/tree/logistic_regression.Rmd" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch onBinder"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img src="_static/images/logo_binder.svg">
  </span>
<span class="btn__text-container">Binder</span>
</a>
</li>
      
      
      
      
      <li><a href="https://ds.lis.2i2c.cloud/hub/user-redirect/git-pull?repo=https%3A//github.com/lisds/dsip&urlpath=lab/tree/dsip/logistic_regression.Rmd&branch=main" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch onJupyterHub"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img src="_static/images/logo_jupyterhub.svg">
  </span>
<span class="btn__text-container">JupyterHub</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="initThebeSBT()"
  class="btn btn-sm btn-launch-thebe dropdown-item"
  title="Launch Thebe"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-play"></i>
  </span>
<span class="btn__text-container">Live Code</span>
</button>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/lisds/dsip" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/lisds/dsip/edit/main/logistic_regression.Rmd" target="_blank"
   class="btn btn-sm btn-source-edit-button dropdown-item"
   title="Suggest edit"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="btn__text-container">Suggest edit</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/lisds/dsip/issues/new?title=Issue%20on%20page%20%2Flogistic_regression.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/logistic_regression.Rmd" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.Rmd</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Logistic regression</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#dummy-variables">Dummy Variables</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#how-about-linear-regression">How about linear regression?</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#another-prediction-line">Another prediction line</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#probability-and-odds">Probability and Odds</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-logarithm-transform">The logarithm transform</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-logit-transform-and-its-inverse">The logit transform and its inverse</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#effect-of-the-logit-slope-and-intercept-on-the-sigmoid">Effect of the Logit slope and intercept on the sigmoid</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-first-pass-at-logistic-regression">A first-pass at logistic regression</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-different-measure-of-prediction-error">A different measure of prediction error</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-computation-trick-for-the-likelihood">A computation trick for the likelihood</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#logistic-regression-with-statsmodes">Logistic Regression with Statsmodes</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-meaning-of-the-parameters">The meaning of the parameters</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#summary">Summary</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="logistic-regression">
<h1>Logistic regression<a class="headerlink" href="#logistic-regression" title="Permalink to this heading">#</a></h1>
<div class="cell tag_hide-cell docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell content</span>
<span class="expanded">Hide code cell content</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="c1"># Safe setting for Pandas.</span>
<span class="n">pd</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s1">&#39;mode.copy_on_write&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">jupyprint</span> <span class="kn">import</span> <span class="n">arraytex</span><span class="p">,</span> <span class="n">jupyprint</span>
<span class="c1"># Optimization function</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>
<span class="c1"># For interactive widgets.</span>
<span class="kn">from</span> <span class="nn">ipywidgets</span> <span class="kn">import</span> <span class="n">interact</span>
</pre></div>
</div>
</div>
</details>
</div>
<p>In this page we will look at another regression technique: logistic regression.
We use logistic regression when we want to use a <em>binary categorical</em>
variable as our <em>outcome</em> variable This contrasts with using a binary categorical
variable <em>as</em> a predictor variable, as we’ve seen on the other <a class="reference external" href="https://lisds.github.io/dsip/linear_regression_categorical_predictors.html">textbook</a> <a class="reference external" href="https://lisds.github.io/dsip/multiple_predictors_statistical_adjustment.html">pages</a>.</p>
<p>As we know, a binary categorical variable is one where an observation can fall
into one of only two categories. We give each observation a label corresponding to their
category.  Some examples are:</p>
<ul class="simple">
<li><p>Did a patient die or did they survive through 6 months of treatment?  The
patient can only be in only one of the categories.  In some column of our
data table, patients that died might have the label “died”, and those who
have survived have the label “survived”.</p></li>
<li><p>Did a person experience more than one episode of psychosis in the last 5
years (“yes” or “no”)?</p></li>
<li><p>Did a person with a conviction for one offense offend again (“yes” or “no”)?</p></li>
</ul>
<p>For this tutorial, we return to the <a class="reference external" href="https://lisds.github.io/textbook/data/chronic_kidney_disease">chronic kidney disease
dataset</a>, which
you have seen previously.</p>
<p>Each observational unit in this dataset is one patient.</p>
<p>For each patient, the doctors recorded whether or not the patient had chronic
kidney disease. This is a <em>binary categorical variable</em>; you can see the
values in the “Class” column. A value of 1 means the patient <em>did</em> have CKD; a
value of 0 means they <em>did not</em>.  Remember that these numbers are not true numbers:
they are labels that denote category membership, but by using numbers as labels
we can “trick” a regression model into including the variable.</p>
<p>Many of the rest of the columns in the dataframe are measurements from blood tests and urine tests.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># read in the data</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;data/ckd_clean.csv&#39;</span><span class="p">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Age</th>
      <th>Blood Pressure</th>
      <th>Specific Gravity</th>
      <th>Albumin</th>
      <th>Sugar</th>
      <th>Red Blood Cells</th>
      <th>Pus Cell</th>
      <th>Pus Cell clumps</th>
      <th>Bacteria</th>
      <th>Blood Glucose Random</th>
      <th>...</th>
      <th>Packed Cell Volume</th>
      <th>White Blood Cell Count</th>
      <th>Red Blood Cell Count</th>
      <th>Hypertension</th>
      <th>Diabetes Mellitus</th>
      <th>Coronary Artery Disease</th>
      <th>Appetite</th>
      <th>Pedal Edema</th>
      <th>Anemia</th>
      <th>Class</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>48.0</td>
      <td>70.0</td>
      <td>1.005</td>
      <td>4.0</td>
      <td>0.0</td>
      <td>normal</td>
      <td>abnormal</td>
      <td>present</td>
      <td>notpresent</td>
      <td>117.0</td>
      <td>...</td>
      <td>32.0</td>
      <td>6700.0</td>
      <td>3.9</td>
      <td>yes</td>
      <td>no</td>
      <td>no</td>
      <td>poor</td>
      <td>yes</td>
      <td>yes</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>53.0</td>
      <td>90.0</td>
      <td>1.020</td>
      <td>2.0</td>
      <td>0.0</td>
      <td>abnormal</td>
      <td>abnormal</td>
      <td>present</td>
      <td>notpresent</td>
      <td>70.0</td>
      <td>...</td>
      <td>29.0</td>
      <td>12100.0</td>
      <td>3.7</td>
      <td>yes</td>
      <td>yes</td>
      <td>no</td>
      <td>poor</td>
      <td>no</td>
      <td>yes</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>63.0</td>
      <td>70.0</td>
      <td>1.010</td>
      <td>3.0</td>
      <td>0.0</td>
      <td>abnormal</td>
      <td>abnormal</td>
      <td>present</td>
      <td>notpresent</td>
      <td>380.0</td>
      <td>...</td>
      <td>32.0</td>
      <td>4500.0</td>
      <td>3.8</td>
      <td>yes</td>
      <td>yes</td>
      <td>no</td>
      <td>poor</td>
      <td>yes</td>
      <td>no</td>
      <td>1</td>
    </tr>
    <tr>
      <th>3</th>
      <td>68.0</td>
      <td>80.0</td>
      <td>1.010</td>
      <td>3.0</td>
      <td>2.0</td>
      <td>normal</td>
      <td>abnormal</td>
      <td>present</td>
      <td>present</td>
      <td>157.0</td>
      <td>...</td>
      <td>16.0</td>
      <td>11000.0</td>
      <td>2.6</td>
      <td>yes</td>
      <td>yes</td>
      <td>yes</td>
      <td>poor</td>
      <td>yes</td>
      <td>no</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>61.0</td>
      <td>80.0</td>
      <td>1.015</td>
      <td>2.0</td>
      <td>0.0</td>
      <td>abnormal</td>
      <td>abnormal</td>
      <td>notpresent</td>
      <td>notpresent</td>
      <td>173.0</td>
      <td>...</td>
      <td>24.0</td>
      <td>9200.0</td>
      <td>3.2</td>
      <td>yes</td>
      <td>yes</td>
      <td>yes</td>
      <td>poor</td>
      <td>yes</td>
      <td>yes</td>
      <td>1</td>
    </tr>
    <tr>
      <th>5</th>
      <td>48.0</td>
      <td>80.0</td>
      <td>1.025</td>
      <td>4.0</td>
      <td>0.0</td>
      <td>normal</td>
      <td>abnormal</td>
      <td>notpresent</td>
      <td>notpresent</td>
      <td>95.0</td>
      <td>...</td>
      <td>32.0</td>
      <td>6900.0</td>
      <td>3.4</td>
      <td>yes</td>
      <td>no</td>
      <td>no</td>
      <td>good</td>
      <td>no</td>
      <td>yes</td>
      <td>1</td>
    </tr>
    <tr>
      <th>6</th>
      <td>69.0</td>
      <td>70.0</td>
      <td>1.010</td>
      <td>3.0</td>
      <td>4.0</td>
      <td>normal</td>
      <td>abnormal</td>
      <td>notpresent</td>
      <td>notpresent</td>
      <td>264.0</td>
      <td>...</td>
      <td>37.0</td>
      <td>9600.0</td>
      <td>4.1</td>
      <td>yes</td>
      <td>yes</td>
      <td>yes</td>
      <td>good</td>
      <td>yes</td>
      <td>no</td>
      <td>1</td>
    </tr>
    <tr>
      <th>7</th>
      <td>73.0</td>
      <td>70.0</td>
      <td>1.005</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>normal</td>
      <td>normal</td>
      <td>notpresent</td>
      <td>notpresent</td>
      <td>70.0</td>
      <td>...</td>
      <td>29.0</td>
      <td>18900.0</td>
      <td>3.5</td>
      <td>yes</td>
      <td>yes</td>
      <td>no</td>
      <td>good</td>
      <td>yes</td>
      <td>no</td>
      <td>1</td>
    </tr>
    <tr>
      <th>8</th>
      <td>73.0</td>
      <td>80.0</td>
      <td>1.020</td>
      <td>2.0</td>
      <td>0.0</td>
      <td>abnormal</td>
      <td>abnormal</td>
      <td>notpresent</td>
      <td>notpresent</td>
      <td>253.0</td>
      <td>...</td>
      <td>33.0</td>
      <td>7200.0</td>
      <td>4.3</td>
      <td>yes</td>
      <td>yes</td>
      <td>yes</td>
      <td>good</td>
      <td>no</td>
      <td>no</td>
      <td>1</td>
    </tr>
    <tr>
      <th>9</th>
      <td>46.0</td>
      <td>60.0</td>
      <td>1.010</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>normal</td>
      <td>normal</td>
      <td>notpresent</td>
      <td>notpresent</td>
      <td>163.0</td>
      <td>...</td>
      <td>28.0</td>
      <td>14600.0</td>
      <td>3.2</td>
      <td>yes</td>
      <td>yes</td>
      <td>no</td>
      <td>good</td>
      <td>no</td>
      <td>no</td>
      <td>1</td>
    </tr>
    <tr>
      <th>10</th>
      <td>56.0</td>
      <td>90.0</td>
      <td>1.015</td>
      <td>2.0</td>
      <td>0.0</td>
      <td>abnormal</td>
      <td>abnormal</td>
      <td>notpresent</td>
      <td>notpresent</td>
      <td>129.0</td>
      <td>...</td>
      <td>29.0</td>
      <td>6400.0</td>
      <td>3.4</td>
      <td>yes</td>
      <td>no</td>
      <td>no</td>
      <td>good</td>
      <td>no</td>
      <td>no</td>
      <td>1</td>
    </tr>
    <tr>
      <th>11</th>
      <td>48.0</td>
      <td>80.0</td>
      <td>1.005</td>
      <td>4.0</td>
      <td>0.0</td>
      <td>abnormal</td>
      <td>abnormal</td>
      <td>notpresent</td>
      <td>present</td>
      <td>133.0</td>
      <td>...</td>
      <td>36.0</td>
      <td>6200.0</td>
      <td>4.0</td>
      <td>no</td>
      <td>yes</td>
      <td>no</td>
      <td>good</td>
      <td>yes</td>
      <td>no</td>
      <td>1</td>
    </tr>
    <tr>
      <th>12</th>
      <td>59.0</td>
      <td>70.0</td>
      <td>1.010</td>
      <td>3.0</td>
      <td>0.0</td>
      <td>normal</td>
      <td>abnormal</td>
      <td>notpresent</td>
      <td>notpresent</td>
      <td>76.0</td>
      <td>...</td>
      <td>22.0</td>
      <td>3800.0</td>
      <td>2.1</td>
      <td>yes</td>
      <td>no</td>
      <td>no</td>
      <td>poor</td>
      <td>yes</td>
      <td>yes</td>
      <td>1</td>
    </tr>
    <tr>
      <th>13</th>
      <td>63.0</td>
      <td>100.0</td>
      <td>1.010</td>
      <td>2.0</td>
      <td>2.0</td>
      <td>normal</td>
      <td>normal</td>
      <td>notpresent</td>
      <td>present</td>
      <td>280.0</td>
      <td>...</td>
      <td>40.0</td>
      <td>9800.0</td>
      <td>4.2</td>
      <td>yes</td>
      <td>no</td>
      <td>yes</td>
      <td>good</td>
      <td>no</td>
      <td>no</td>
      <td>1</td>
    </tr>
    <tr>
      <th>14</th>
      <td>56.0</td>
      <td>70.0</td>
      <td>1.015</td>
      <td>4.0</td>
      <td>1.0</td>
      <td>abnormal</td>
      <td>normal</td>
      <td>notpresent</td>
      <td>notpresent</td>
      <td>210.0</td>
      <td>...</td>
      <td>52.0</td>
      <td>12500.0</td>
      <td>5.6</td>
      <td>no</td>
      <td>no</td>
      <td>no</td>
      <td>good</td>
      <td>no</td>
      <td>no</td>
      <td>1</td>
    </tr>
    <tr>
      <th>15</th>
      <td>71.0</td>
      <td>70.0</td>
      <td>1.010</td>
      <td>3.0</td>
      <td>0.0</td>
      <td>normal</td>
      <td>abnormal</td>
      <td>present</td>
      <td>present</td>
      <td>219.0</td>
      <td>...</td>
      <td>33.0</td>
      <td>5600.0</td>
      <td>3.6</td>
      <td>yes</td>
      <td>yes</td>
      <td>yes</td>
      <td>good</td>
      <td>no</td>
      <td>no</td>
      <td>1</td>
    </tr>
    <tr>
      <th>16</th>
      <td>73.0</td>
      <td>100.0</td>
      <td>1.010</td>
      <td>3.0</td>
      <td>2.0</td>
      <td>abnormal</td>
      <td>abnormal</td>
      <td>present</td>
      <td>notpresent</td>
      <td>295.0</td>
      <td>...</td>
      <td>30.0</td>
      <td>7000.0</td>
      <td>3.2</td>
      <td>yes</td>
      <td>yes</td>
      <td>yes</td>
      <td>poor</td>
      <td>no</td>
      <td>no</td>
      <td>1</td>
    </tr>
    <tr>
      <th>17</th>
      <td>71.0</td>
      <td>60.0</td>
      <td>1.015</td>
      <td>4.0</td>
      <td>0.0</td>
      <td>normal</td>
      <td>normal</td>
      <td>notpresent</td>
      <td>notpresent</td>
      <td>118.0</td>
      <td>...</td>
      <td>35.0</td>
      <td>15200.0</td>
      <td>4.3</td>
      <td>yes</td>
      <td>yes</td>
      <td>no</td>
      <td>poor</td>
      <td>yes</td>
      <td>no</td>
      <td>1</td>
    </tr>
    <tr>
      <th>18</th>
      <td>52.0</td>
      <td>90.0</td>
      <td>1.015</td>
      <td>4.0</td>
      <td>3.0</td>
      <td>normal</td>
      <td>abnormal</td>
      <td>notpresent</td>
      <td>notpresent</td>
      <td>224.0</td>
      <td>...</td>
      <td>23.0</td>
      <td>5000.0</td>
      <td>2.9</td>
      <td>yes</td>
      <td>yes</td>
      <td>no</td>
      <td>good</td>
      <td>no</td>
      <td>yes</td>
      <td>1</td>
    </tr>
    <tr>
      <th>19</th>
      <td>50.0</td>
      <td>90.0</td>
      <td>1.010</td>
      <td>2.0</td>
      <td>0.0</td>
      <td>normal</td>
      <td>abnormal</td>
      <td>present</td>
      <td>present</td>
      <td>128.0</td>
      <td>...</td>
      <td>22.0</td>
      <td>16300.0</td>
      <td>2.7</td>
      <td>no</td>
      <td>no</td>
      <td>no</td>
      <td>poor</td>
      <td>yes</td>
      <td>yes</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
<p>20 rows × 25 columns</p>
</div></div></div>
</div>
<p>There are actually a large number of binary categorical variables in this
dataset.   For example, the “Hypertension” column has labels for the two
categories “yes” (the patient had persistently high blood pressure) or “no”.</p>
<p>The categorical variable we are interested in here is “Appetite”.  This has
the label “good” for patients with good appetite, and “poor” for those with
poor appetite.  Poor appetite is a <a class="reference external" href="https://www.sciencedirect.com/science/article/abs/pii/S0270929508001666">symptom of chronic kidney
disease</a>.  In our case, we wonder whether the extent of kidney damage does a convincing job in predicting whether the patient has a “good” appetite.</p>
<p>The CKD dataset has a column “Hemoglobin” that has the
concentration of hemoglobin from a blood sample.  Hemoglobin is the molecule
that carries oxygen in the blood; it is the molecule that makes the red blood
cells red.  Damaged kidneys produce lower concentrations of the hormone that
stimulates red blood cell production,
<a class="reference external" href="https://en.wikipedia.org/wiki/Erythropoietin">erythropoietin</a>, so CKD
patients often have fewer red blood cells, and lower concentrations of
Hemoglobin.  We will take lower “Hemoglobin” as a index of kidney damage.
Therefore, we predict that patients with lower “Hemoglobin” values are more
likely to have <code class="docutils literal notranslate"><span class="pre">poor</span></code> “Appetite” values, and, conversely, patients with higher
“Hemoglobin” values are more likely to have <code class="docutils literal notranslate"><span class="pre">good</span></code> “Appetite” values.</p>
<p>First we make a new data frame that just has the two columns we are interested
in:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># isolate only the variables of interest</span>
<span class="n">hgb_app</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">[</span><span class="s1">&#39;Hemoglobin&#39;</span><span class="p">,</span> <span class="s1">&#39;Appetite&#39;</span><span class="p">]]</span>

<span class="c1"># rename the columns for easier typing</span>
<span class="n">hgb_app</span> <span class="o">=</span> <span class="n">hgb_app</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Hemoglobin&#39;</span><span class="p">:</span> <span class="s1">&#39;hemoglobin&#39;</span><span class="p">,</span>
                                    <span class="s1">&#39;Appetite&#39;</span> <span class="p">:</span> <span class="s1">&#39;appetite&#39;</span><span class="p">})</span>
<span class="n">hgb_app</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>hemoglobin</th>
      <th>appetite</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>11.2</td>
      <td>poor</td>
    </tr>
    <tr>
      <th>1</th>
      <td>9.5</td>
      <td>poor</td>
    </tr>
    <tr>
      <th>2</th>
      <td>10.8</td>
      <td>poor</td>
    </tr>
    <tr>
      <th>3</th>
      <td>5.6</td>
      <td>poor</td>
    </tr>
    <tr>
      <th>4</th>
      <td>7.7</td>
      <td>poor</td>
    </tr>
    <tr>
      <th>5</th>
      <td>9.8</td>
      <td>good</td>
    </tr>
    <tr>
      <th>6</th>
      <td>12.5</td>
      <td>good</td>
    </tr>
    <tr>
      <th>7</th>
      <td>10.0</td>
      <td>good</td>
    </tr>
    <tr>
      <th>8</th>
      <td>10.5</td>
      <td>good</td>
    </tr>
    <tr>
      <th>9</th>
      <td>9.8</td>
      <td>good</td>
    </tr>
    <tr>
      <th>10</th>
      <td>9.1</td>
      <td>good</td>
    </tr>
    <tr>
      <th>11</th>
      <td>10.3</td>
      <td>good</td>
    </tr>
    <tr>
      <th>12</th>
      <td>7.1</td>
      <td>poor</td>
    </tr>
    <tr>
      <th>13</th>
      <td>13.0</td>
      <td>good</td>
    </tr>
    <tr>
      <th>14</th>
      <td>16.1</td>
      <td>good</td>
    </tr>
    <tr>
      <th>15</th>
      <td>10.4</td>
      <td>good</td>
    </tr>
    <tr>
      <th>16</th>
      <td>9.2</td>
      <td>poor</td>
    </tr>
    <tr>
      <th>17</th>
      <td>11.4</td>
      <td>poor</td>
    </tr>
    <tr>
      <th>18</th>
      <td>8.1</td>
      <td>good</td>
    </tr>
    <tr>
      <th>19</th>
      <td>8.2</td>
      <td>poor</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<section id="dummy-variables">
<h2>Dummy Variables<a class="headerlink" href="#dummy-variables" title="Permalink to this heading">#</a></h2>
<p>The model we want to fit is here is:</p>
<p><code class="docutils literal notranslate"><span class="pre">appetite</span></code> ~ <code class="docutils literal notranslate"><span class="pre">hemoglobin</span></code></p>
<p>Which we read as “we want to model <code class="docutils literal notranslate"><span class="pre">appetite</span></code> as a function of <code class="docutils literal notranslate"><span class="pre">hemoglobin</span></code>”.</p>
<p>We will soon find ourselves wanting to do calculations on the values in the
<code class="docutils literal notranslate"><span class="pre">appetite</span></code> column, and we cannot easily do that with the current string values
of “good” and “poor”, for the reasons we’ve seen previously, on the categorical
predictors <a class="reference external" href="https://lisds.github.io/dsip/linear_regression_categorical_predictors.html">page</a>.</p>
<p>Just as when we use a categorical variable as a predictor,
our next step is to recode the string values to
numbers, ready for our calculations.  We use 1 to represent “good” and 0 to
represent “poor”.  This kind of recoding, where we replace category labels
with 1 and 0 values, is often called <em>dummy coding</em>. The notation for the current
dummy-coding scheme is:</p>
<p><code class="docutils literal notranslate"><span class="pre">appetite_dummy</span></code> <span class="math notranslate nohighlight">\( = \begin{cases} 1, &amp; \text{if \)</span>i<span class="math notranslate nohighlight">\( is `good`} \\ 0, &amp; \text{if \)</span>i<span class="math notranslate nohighlight">\( is `poor`} \end{cases} \)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># &#39;replace&#39; replaces the values in the first argument with the corresponding</span>
<span class="c1"># values in the second argument.</span>
<span class="n">hgb_app</span><span class="p">[</span><span class="s1">&#39;appetite_dummy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hgb_app</span><span class="p">[</span><span class="s1">&#39;appetite&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">([</span><span class="s1">&#39;poor&#39;</span><span class="p">,</span> <span class="s1">&#39;good&#39;</span><span class="p">],</span>
                                                        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">hgb_app</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/tmp/ipykernel_3762/3666758790.py:3: FutureWarning: Downcasting behavior in `replace` is deprecated and will be removed in a future version. To retain the old behavior, explicitly call `result.infer_objects(copy=False)`. To opt-in to the future behavior, set `pd.set_option(&#39;future.no_silent_downcasting&#39;, True)`
  hgb_app[&#39;appetite_dummy&#39;] = hgb_app[&#39;appetite&#39;].replace([&#39;poor&#39;, &#39;good&#39;],
</pre></div>
</div>
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>hemoglobin</th>
      <th>appetite</th>
      <th>appetite_dummy</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>11.2</td>
      <td>poor</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>9.5</td>
      <td>poor</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>10.8</td>
      <td>poor</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>5.6</td>
      <td>poor</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>7.7</td>
      <td>poor</td>
      <td>0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>9.8</td>
      <td>good</td>
      <td>1</td>
    </tr>
    <tr>
      <th>6</th>
      <td>12.5</td>
      <td>good</td>
      <td>1</td>
    </tr>
    <tr>
      <th>7</th>
      <td>10.0</td>
      <td>good</td>
      <td>1</td>
    </tr>
    <tr>
      <th>8</th>
      <td>10.5</td>
      <td>good</td>
      <td>1</td>
    </tr>
    <tr>
      <th>9</th>
      <td>9.8</td>
      <td>good</td>
      <td>1</td>
    </tr>
    <tr>
      <th>10</th>
      <td>9.1</td>
      <td>good</td>
      <td>1</td>
    </tr>
    <tr>
      <th>11</th>
      <td>10.3</td>
      <td>good</td>
      <td>1</td>
    </tr>
    <tr>
      <th>12</th>
      <td>7.1</td>
      <td>poor</td>
      <td>0</td>
    </tr>
    <tr>
      <th>13</th>
      <td>13.0</td>
      <td>good</td>
      <td>1</td>
    </tr>
    <tr>
      <th>14</th>
      <td>16.1</td>
      <td>good</td>
      <td>1</td>
    </tr>
    <tr>
      <th>15</th>
      <td>10.4</td>
      <td>good</td>
      <td>1</td>
    </tr>
    <tr>
      <th>16</th>
      <td>9.2</td>
      <td>poor</td>
      <td>0</td>
    </tr>
    <tr>
      <th>17</th>
      <td>11.4</td>
      <td>poor</td>
      <td>0</td>
    </tr>
    <tr>
      <th>18</th>
      <td>8.1</td>
      <td>good</td>
      <td>1</td>
    </tr>
    <tr>
      <th>19</th>
      <td>8.2</td>
      <td>poor</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p><em>Note</em>: When you are doing this, be sure to keep track of which label you have
coded as 1. Normally this would be the more interesting outcome.  In this
case, “good” has the code 1. Keep track of the label corresponding to 1, as it
will affect the interpretation of the regression coefficients.</p>
<p>Now we have the dummy (1 or 0) variable, let us use a scatter plot to look at
the relationship between hemoglobin concentration and whether a patient has a
good appetite.</p>
<div class="cell tag_remove-input docutils container">
<div class="cell_output docutils container">
<img alt="_images/07886eb55a5bacd84020cfdaa0ca5d814de72af6babbabe18fdf3657d5adbd84.png" src="_images/07886eb55a5bacd84020cfdaa0ca5d814de72af6babbabe18fdf3657d5adbd84.png" />
</div>
</div>
<p>From the plot, it does look as if the patients with lower hemoglobin are more
likely to have poor appetite (<code class="docutils literal notranslate"><span class="pre">appetite_dummy</span></code> values of 0), whereas patients
with higher hemoglobin tend to have good appetite (<code class="docutils literal notranslate"><span class="pre">appetite_dummy</span></code> values of
1).</p>
<p>Now we start to get more formal, and develop a model with which we predict the
<code class="docutils literal notranslate"><span class="pre">appetite_dummy</span></code> values from the  <code class="docutils literal notranslate"><span class="pre">Hemoglobin</span></code> values.</p>
</section>
<section id="how-about-linear-regression">
<h2>How about linear regression?<a class="headerlink" href="#how-about-linear-regression" title="Permalink to this heading">#</a></h2>
<p>Remember that, in linear regression, we predict scores on the <em>outcome</em>
variable (or vector) using a straight-line relationship of the <em>predictor</em>
variable (or vector).</p>
<p>Here are the predictor and outcome variables in our case - we’ll store these
as separate variables to save some typing:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># The x (predictor) and y (outcome) variables.</span>
<span class="n">hemoglobin</span> <span class="o">=</span> <span class="n">hgb_app</span><span class="p">[</span><span class="s1">&#39;hemoglobin&#39;</span><span class="p">]</span>
<span class="n">appetite_d</span> <span class="o">=</span> <span class="n">hgb_app</span><span class="p">[</span><span class="s1">&#39;appetite_dummy&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Why not use linear regression for the present data? After all, our <em>outcome variable</em> (<code class="docutils literal notranslate"><span class="pre">appetite_d</span></code>) and our <em>predictor variable</em> (<code class="docutils literal notranslate"><span class="pre">hemoglobin</span></code>) here are both sequences of numbers, with one value for each observational unit (row) in the dataset. The linear model here is shown below, using the first 20 values of each vector (to stop the printout being unwieldy)!:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># do not worry about this code, it just generates the notation below</span>
<span class="n">jupyprint</span><span class="p">(</span><span class="s2">&quot;Here is the our model ($ </span><span class="se">\\</span><span class="s2">vec</span><span class="si">{y}</span><span class="s2"> = b </span><span class="se">\\</span><span class="s2">vec</span><span class="si">{x}</span><span class="s2"> + </span><span class="se">\\</span><span class="s2">text</span><span class="si">{c}</span><span class="s2"> + </span><span class="se">\\</span><span class="s2">vec{</span><span class="se">\\</span><span class="s2">varepsilon} $), showing the first 10 actual values within the `hemoglobin` and `appetite_d` vectors:&quot;</span><span class="p">)</span>
<span class="n">jupyprint</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;$</span><span class="si">{</span><span class="n">arraytex</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">appetite_d</span><span class="p">[:</span><span class="mi">20</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="si">}</span><span class="s2"> = b * </span><span class="si">{</span><span class="n">arraytex</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">hemoglobin</span><span class="p">[:</span><span class="mi">20</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="si">}</span><span class="s2"> + c +&quot;</span> <span class="o">+</span><span class="s2">&quot; </span><span class="se">\\</span><span class="s2">vec{</span><span class="se">\\</span><span class="s2">varepsilon}$&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<p>Here is the our model ($ \vec{y} = b \vec{x} + \text{c} + \vec{\varepsilon} $), showing the first 10 actual values within the <code class="docutils literal notranslate"><span class="pre">hemoglobin</span></code> and <code class="docutils literal notranslate"><span class="pre">appetite_d</span></code> vectors:</p>
<p>$\begin{bmatrix}{} 0 \ 0 \ 0 \ 0 \ 0 \ 1 \ 1 \ 1 \ 1 \ 1 \ 1 \ 1 \ 0 \ 1 \ 1 \ 1 \ 0 \ 0 \ 1 \ 0 \ \end{bmatrix} = b * \begin{bmatrix}{} 11.2 \ 9.5 \ 10.8 \ 5.6 \ 7.7 \ 9.8 \ 12.5 \ 10.0 \ 10.5 \ 9.8 \ 9.1 \ 10.3 \ 7.1 \ 13.0 \ 16.1 \ 10.4 \ 9.2 \ 11.4 \ 8.1 \ 8.2 \ \end{bmatrix} + c + \vec{\varepsilon}$</p>
</div>
</div>
<p>Let’s compare the values in the vectors above to the first 20 values of each variable in the <code class="docutils literal notranslate"><span class="pre">hgb_app</span></code> dataframe, just to
assure ourselves they are the same:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># for comparison with the vectors above</span>
<span class="n">hgb_app</span><span class="p">[[</span><span class="s1">&#39;appetite_dummy&#39;</span><span class="p">,</span> <span class="s1">&#39;hemoglobin&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">20</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>appetite_dummy</th>
      <th>hemoglobin</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>11.2</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0</td>
      <td>9.5</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0</td>
      <td>10.8</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0</td>
      <td>5.6</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0</td>
      <td>7.7</td>
    </tr>
    <tr>
      <th>5</th>
      <td>1</td>
      <td>9.8</td>
    </tr>
    <tr>
      <th>6</th>
      <td>1</td>
      <td>12.5</td>
    </tr>
    <tr>
      <th>7</th>
      <td>1</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th>8</th>
      <td>1</td>
      <td>10.5</td>
    </tr>
    <tr>
      <th>9</th>
      <td>1</td>
      <td>9.8</td>
    </tr>
    <tr>
      <th>10</th>
      <td>1</td>
      <td>9.1</td>
    </tr>
    <tr>
      <th>11</th>
      <td>1</td>
      <td>10.3</td>
    </tr>
    <tr>
      <th>12</th>
      <td>0</td>
      <td>7.1</td>
    </tr>
    <tr>
      <th>13</th>
      <td>1</td>
      <td>13.0</td>
    </tr>
    <tr>
      <th>14</th>
      <td>1</td>
      <td>16.1</td>
    </tr>
    <tr>
      <th>15</th>
      <td>1</td>
      <td>10.4</td>
    </tr>
    <tr>
      <th>16</th>
      <td>0</td>
      <td>9.2</td>
    </tr>
    <tr>
      <th>17</th>
      <td>0</td>
      <td>11.4</td>
    </tr>
    <tr>
      <th>18</th>
      <td>1</td>
      <td>8.1</td>
    </tr>
    <tr>
      <th>19</th>
      <td>0</td>
      <td>8.2</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>This looks like something our linear regression machinery will be able to work with.</p>
<p>In contrast to the vector printout above, we actually have many more than 20 observational units:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">jupyprint</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Rows in CKD data: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">hgb_app</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<p>Rows in CKD data: 158</p>
</div>
</div>
<p>We are familiar now with performing linear regression to
find the value of the slope and intercept of the line which gives the smallest
sum of the squared prediction errors.</p>
<p>Recall that, in linear regression:</p>
<p><span class="math notranslate nohighlight">\( \text{(predicted scores)} = b * \text{(predictor variable)} + c \)</span></p>
<p>Or, in mathematical notation:</p>
<p><span class="math notranslate nohighlight">\(\Large \vec{\hat{y}} = b \vec{x} + \text{c}\)</span></p>
<p>As we know, there will be the same number of scores on the
predictor variable (<code class="docutils literal notranslate"><span class="pre">hemoglobin</span></code>), and the same number of predictions (<span class="math notranslate nohighlight">\(\hat{y}\)</span>).
By contrast, the slope and intercept are single values, defining
the line.</p>
<p>We used <code class="docutils literal notranslate"><span class="pre">minimize</span></code> to find the values of the slope and intercept which give the
“best” predictions.  So far, we have almost invariably defined the <em>best</em>
values for slope and intercept as the values that give the smallest sum of the
squared prediction errors.</p>
<p><span class="math notranslate nohighlight">\(\text{(prediction errors)} = \text{(actual scores) - (predicted scores)}\)</span></p>
<p>Or, in mathematical notation:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\vec{\varepsilon}= \begin{bmatrix}
           \varepsilon_1 \\
           \varepsilon_2 \\
           \vdots \\
           \varepsilon_n
         \end{bmatrix} = \begin{bmatrix}
           y_1 - \hat{y}_1 \\
           y_2 - \hat{y}_2 \\
           \vdots \\
           y_n - \hat{y}_n
         \end{bmatrix}         = 
         \begin{bmatrix}
           y_1 - (b x_1 + c)\\
           y_2 - (b x_2 + c) \\
           \vdots \\
           y_n - (b x_n + c)
         \end{bmatrix}         
\end{split}\]</div>
<p>What would happen if we tried to use linear regression to predict the
appetite scores, based on hemoglobin concentrations?</p>
<p>Let us start by grabbing the our familiar <code class="docutils literal notranslate"><span class="pre">ss_any_line</span></code> function from the
<a class="reference external" href="https://lisds.github.io/textbook/mean-slopes/using_minimize">Using minimize
page</a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">ss_any_line</span><span class="p">(</span><span class="n">intercept_and_slope</span><span class="p">,</span> <span class="n">x_values</span><span class="p">,</span> <span class="n">y_values</span><span class="p">):</span>
    
    <span class="c1"># Intercept_and_slope is a list containing two elements, an intercept and a slope.</span>
    <span class="n">intercept</span><span class="p">,</span> <span class="n">slope</span> <span class="o">=</span><span class="n">intercept_and_slope</span>
    
    <span class="c1"># Values predicted from these x_values, using this intercept and slope.</span>
    <span class="n">predicted</span> <span class="o">=</span> <span class="n">intercept</span> <span class="o">+</span> <span class="n">x_values</span> <span class="o">*</span> <span class="n">slope</span>
    
    <span class="c1"># Difference of prediction from the actual y values.</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">y_values</span> <span class="o">-</span> <span class="n">predicted</span>
    
    <span class="c1"># Sum of squared error.</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">error</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>As we know, the sum of the squared prediction error, in linear regression, is our <em>cost</em>
function. When we have a good pair of (intercept, slope) in <code class="docutils literal notranslate"><span class="pre">intercept_and_slope</span></code>, our function
is <em>cheap</em> - i.e. the returned value is small.  When we have a bad pair in
<code class="docutils literal notranslate"><span class="pre">intercept_and_slope</span></code>, our function is <em>expensive</em> - the returned value is large.</p>
<p>If the value from <code class="docutils literal notranslate"><span class="pre">ss_any_line</span></code> is large, it means the line we are fitting
does not fit the data well. The purpose of linear regression is to find the
line which leads to the smallest cost.  In our case, the cost is the sum of the
squared prediction errors.</p>
<p>Let’s use linear regression on the current example.  From looking at our plot
above, we start with a guess of -1 for the intercept, and 0.1 for the slope.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Use minimize to find the least sum of squares solution.</span>
<span class="n">min_lin_reg</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">ss_any_line</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">hemoglobin</span><span class="p">,</span> <span class="n">appetite_d</span><span class="p">))</span>
<span class="c1"># Show the results that came back from minimize.</span>
<span class="n">min_lin_reg</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>  message: Optimization terminated successfully.
  success: True
   status: 0
      fun: 0.06528803495205858
        x: [-7.904e-02  7.005e-02]
      nit: 3
      jac: [ 9.313e-10  1.863e-09]
 hess_inv: [[ 1.185e+01 -8.291e-01]
            [-8.291e-01  6.057e-02]]
     nfev: 18
     njev: 6
</pre></div>
</div>
</div>
</div>
<p>OK, so that looks hopeful. Using linear regression with <code class="docutils literal notranslate"><span class="pre">minimize</span></code> we found that the sum of squared prediction errors was smallest for a line with:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Unpack the slope and intercept estimates from the results object.</span>
<span class="n">lin_reg_intercept</span><span class="p">,</span> <span class="n">lin_reg_slope</span> <span class="o">=</span> <span class="n">min_lin_reg</span><span class="o">.</span><span class="n">x</span>
<span class="c1"># Show them.</span>
<span class="n">jupyprint</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Best linear regression intercept &lt;b&gt; </span><span class="si">{</span><span class="n">lin_reg_intercept</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s1">&lt;/b&gt;&#39;</span><span class="p">)</span>
<span class="n">jupyprint</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Best linear regression slope &lt;b&gt; </span><span class="si">{</span><span class="n">lin_reg_slope</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s1"> &lt;/b&gt;&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<p>Best linear regression intercept <b> -0.08</b></p>
<p>Best linear regression slope <b> 0.07 </b></p>
</div>
</div>
<p>Let’s calculate the predicted scores, from the now familiar formula:</p>
<p><span class="math notranslate nohighlight">\(\vec{\hat{y}} = b \vec{x} + \text{c}\)</span></p>
<p>Which, in python terms, in the current case, is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">predicted_scores</span><span class="o">=</span> <span class="n">lin_reg_slope</span> <span class="o">*</span> <span class="n">hemoglobin</span> <span class="o">+</span> <span class="n">lin_reg_intercept</span>
</pre></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># calculate the predicted values</span>
<span class="n">predicted_lin_reg</span> <span class="o">=</span> <span class="n">lin_reg_slope</span> <span class="o">*</span> <span class="n">hemoglobin</span> <span class="o">+</span> <span class="n">lin_reg_intercept</span> 
<span class="n">predicted_lin_reg</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0      0.705510
1      0.586427
2      0.677491
3      0.313234
4      0.460338
         ...   
153    1.020732
154    1.076771
155    1.027737
156    0.915658
157    1.027737
Name: hemoglobin, Length: 158, dtype: float64
</pre></div>
</div>
</div>
</div>
<p>Let’s plot our predictions, alongside the actual data.  We plot the predictions
from linear regression in orange.</p>
<div class="cell tag_remove-input docutils container">
<div class="cell_output docutils container">
<img alt="_images/6de147076122858ffe071e6c192bdb4482c09a5c7489e473cf25322582d917e1.png" src="_images/6de147076122858ffe071e6c192bdb4482c09a5c7489e473cf25322582d917e1.png" />
</div>
</div>
<p><i> <b> Question: </b> can anyone see any issues with our predictions here? </i></p>
<p>The linear regression line looks plausible, as far as it goes, but it has
several unhappy features for our task of predicting the <code class="docutils literal notranslate"><span class="pre">appetite_d</span></code> 0 or 1
values.</p>
<p>One thing to like about the line is that the predictions are right to suggest
that the value of <code class="docutils literal notranslate"><span class="pre">appetite_d</span></code> is more likely to be 1 (meaning “good”) at
higher values of <code class="docutils literal notranslate"><span class="pre">hemoglobin</span></code>.  Also, the prediction line slopes upward as
<code class="docutils literal notranslate"><span class="pre">hemoglobin</span></code> gets higher, indicating that the probability of good appetite gets
higher as the hemoglobin concentration rises, across patients.</p>
<p>However, when the <code class="docutils literal notranslate"><span class="pre">hemoglobin</span></code> gets higher than about 15.5, linear regression
starts to predict a value for <code class="docutils literal notranslate"><span class="pre">appetite_d</span></code> that is greater than 1 - which, of
course, cannot occur in the <code class="docutils literal notranslate"><span class="pre">appetite_d</span></code> values, which are restricted to 0 or
1.</p>
<p>In fact, if we make predictions from this model for sufficiently low hemoglobin
values, we find that our predictions for <code class="docutils literal notranslate"><span class="pre">appettite_d</span></code> also fall <em>below</em> 0, which
again, is not a possible value of <code class="docutils literal notranslate"><span class="pre">appetite_d</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Do the base plot of the hemoglobin and appetite_d.</span>
<span class="n">plot_hgb_app</span><span class="p">()</span>

<span class="c1"># A new plot on top of the old.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hemoglobin</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span> 
            <span class="n">lin_reg_intercept</span> <span class="o">+</span> <span class="n">lin_reg_slope</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hemoglobin</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span>
            <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Linear regression prediction $(\hat</span><span class="si">{y}</span><span class="s1">$)&#39;</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s1">&#39;orange&#39;</span><span class="p">)</span>
<span class="c1"># Another plot, to show the underlying line</span>
<span class="n">fine_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">hemoglobin</span><span class="p">),</span> <span class="mi">1000</span><span class="p">)</span>
<span class="n">fine_y</span> <span class="o">=</span> <span class="n">lin_reg_intercept</span> <span class="o">+</span> <span class="n">lin_reg_slope</span> <span class="o">*</span> <span class="n">fine_x</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fine_x</span><span class="p">,</span> <span class="n">fine_y</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
<span class="c1"># Show the legend.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="p">(</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/6c1777b00e1e0c4b55cd90e8f533b6a9cf223dfcc3dcb0ba81916e7b0beb7989.png" src="_images/6c1777b00e1e0c4b55cd90e8f533b6a9cf223dfcc3dcb0ba81916e7b0beb7989.png" />
</div>
</div>
<p>The problem here is that linear regression can produce predicted values (<span class="math notranslate nohighlight">\(\hat{y}\)</span>) ranging from negative infinity to positive infinity. One way of saying this is that the predictions from linear regression are unconstrained or unbounded.</p>
<p>However, the outcome variable we are trying to predict (<code class="docutils literal notranslate"><span class="pre">appetite_d</span></code>) <em>is</em> constrained/bounded: it can only take values of either 0 or 1.</p>
<p>The plot below shows this problem, by showing the linear regression line for very large and very small values of <code class="docutils literal notranslate"><span class="pre">hemoglobin</span></code>, based on the model parameters:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Do the base plot of the hemoglobin and appetite_d.</span>
<span class="n">plot_hgb_app</span><span class="p">()</span>

<span class="c1"># A new plot on top of the old.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hemoglobin</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span> 
            <span class="n">lin_reg_intercept</span> <span class="o">+</span> <span class="n">lin_reg_slope</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hemoglobin</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span>
            <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Linear regression prediction $(\hat</span><span class="si">{y}</span><span class="s1">$)&#39;</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s1">&#39;orange&#39;</span><span class="p">)</span>
<span class="c1"># Another plot, to show the underlying line</span>
<span class="n">fine_x_big</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="n">fine_y_big</span> <span class="o">=</span> <span class="n">lin_reg_intercept</span> <span class="o">+</span> <span class="n">lin_reg_slope</span> <span class="o">*</span> <span class="n">fine_x_big</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fine_x_big</span><span class="p">,</span> <span class="n">fine_y_big</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
<span class="c1"># Show the legend.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="p">(</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/0d4f509300936290be488f783b892e32c5fc9226e770a2b49828f5e05df5a031.png" src="_images/0d4f509300936290be488f783b892e32c5fc9226e770a2b49828f5e05df5a031.png" />
</div>
</div>
<p>These reflections might make as wonder whether we should be using something other
than a simple, unconstrained straight line for our predictions.</p>
</section>
<section id="another-prediction-line">
<h2>Another prediction line<a class="headerlink" href="#another-prediction-line" title="Permalink to this heading">#</a></h2>
<p>Here’s another prediction line we might use for <code class="docutils literal notranslate"><span class="pre">appetite_d</span></code>, with the
predicted values. For the moment, let’s not worry about how we came by this line, we will come
onto that soon. (If it wasn’t obvious, this is the sort of prediction line we get from
logistic regression)!</p>
<p>We will show to the mechanics of how we get such a prediction line -
but for now, we will only say it involves a different cost function
to the one we use in linear regression.</p>
<p>For now, let’s appreciate why the new line might work better than the linear regression line, for the
current data.</p>
<p>The new prediction line is in gold.</p>
<div class="cell tag_hide-cell docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell content</span>
<span class="expanded">Hide code cell content</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># This is the machinery for making the sigmoid line of the plots below.  We</span>
<span class="c1"># will come on that machinery soon.  For now please ignore this code, and</span>
<span class="c1"># concentrate on the plots below.</span>
<span class="k">def</span> <span class="nf">inverse_logit</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Reverse logit transformation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">odds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>  <span class="c1"># Reverse the log operation.</span>
    <span class="k">return</span> <span class="n">odds</span> <span class="o">/</span> <span class="p">(</span><span class="n">odds</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Reverse odds operation.</span>


<span class="k">def</span> <span class="nf">params_to_predicted_probabilities</span><span class="p">(</span><span class="n">intercept</span><span class="p">,</span> <span class="n">slope</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Calculate predicted probability of of `dummy_variable == 1` for each observation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Predicted log odds of being in class 1.</span>
    <span class="n">predicted_log_odds</span> <span class="o">=</span> <span class="n">intercept</span> <span class="o">+</span> <span class="n">slope</span> <span class="o">*</span> <span class="n">x</span>
    <span class="k">return</span> <span class="n">inverse_logit</span><span class="p">(</span><span class="n">predicted_log_odds</span><span class="p">)</span>


<span class="c1"># Some plausible values for intercept and slope.</span>
<span class="n">nice_intercept</span><span class="p">,</span> <span class="n">nice_slope</span> <span class="o">=</span> <span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="mf">0.8</span>
<span class="n">predictions_new</span> <span class="o">=</span> <span class="n">params_to_predicted_probabilities</span><span class="p">(</span><span class="n">nice_intercept</span><span class="p">,</span> <span class="n">nice_slope</span><span class="p">,</span> <span class="n">hemoglobin</span><span class="p">)</span>

<span class="c1"># Do the base plot of the hemoglobin and appetite_d.</span>
<span class="n">plot_hgb_app</span><span class="p">()</span>

<span class="c1"># A new plot on top of the old.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">hemoglobin</span><span class="p">,</span> <span class="n">predictions_new</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s1">&#39;New prediction </span><span class="se">\n</span><span class="s1">(from logistic regression)&#39;</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gold&#39;</span><span class="p">)</span>
<span class="c1"># Another plot, to show the underlying line</span>
<span class="n">fine_y_sigmoid</span> <span class="o">=</span> <span class="n">params_to_predicted_probabilities</span><span class="p">(</span><span class="n">nice_intercept</span><span class="p">,</span> <span class="n">nice_slope</span><span class="p">,</span> <span class="n">fine_x</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fine_x</span><span class="p">,</span> <span class="n">fine_y_sigmoid</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
<span class="c1"># Show the legend.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="p">(</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;A different prediction line&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/c45d4ae89f55c071bf477c00a93b4aaca71269b59f74093c7f85ae53e6885e5b.png" src="_images/c45d4ae89f55c071bf477c00a93b4aaca71269b59f74093c7f85ae53e6885e5b.png" />
</div>
</details>
</div>
<p>The new not-straight line - from now on let’s call it a curve - seems to have much to recommend it.  This shape of
curve is called “sigmoid”, from the name of the Greek letter “s”.</p>
<p>One nice feature of the sigmoid curve is that the sigmoid
prediction here never goes above 1 or below 0, so its values are always in the
range of the <code class="docutils literal notranslate"><span class="pre">appetite_d</span></code> data it is trying to predict.</p>
<p>The sigmoid curve climbs steeply to a prediction of 1, and plateaus there, as we get to the
threshold of hemoglobin around 12.5, at which every patient does seem to have
“good” appetite (<code class="docutils literal notranslate"><span class="pre">appetite_d</span></code> of 1). This is a nice feature, as the predictions
at higher values of <code class="docutils literal notranslate"><span class="pre">hemoglobin</span></code> fit the data better than the linear regression line did.</p>
<p>We can think of the values from the sigmoid curve as being <em>predicted
probabilities</em> an observational unit falling in whichever category we
have dummy coded as 1.</p>
<p>So in the present case, the curve shows us the predicted probability of having
a good appetite, for each observational unit (patient), given that patient’s
<code class="docutils literal notranslate"><span class="pre">hemoglobin</span></code> score.</p>
<p>For example, at a <code class="docutils literal notranslate"><span class="pre">hemoglobin</span></code> value of 10, the curve gives a
predicted y (<code class="docutils literal notranslate"><span class="pre">appetite_d</span></code>) value of about 0.73.  We can interpret this
prediction as saying that, with a hemoglobin value of 10, there is a
<em>probability</em> of about 0.73 that the corresponding patient will have a “good”
appetite (<code class="docutils literal notranslate"><span class="pre">appetite_d</span></code> value of 1).</p>
<p>Red dashed lines have been added to the plot, to show this prediction:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Do the base plot of the hemoglobin and appetite_d.</span>
<span class="n">plot_hgb_app</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Predicted Probability </span><span class="se">\n</span><span class="s1"> (`appetite_d == 1`)&#39;</span><span class="p">)</span>

<span class="c1"># A new plot on top of the old.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">hemoglobin</span><span class="p">,</span> <span class="n">predictions_new</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s1">&#39;New prediction&#39;</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gold&#39;</span><span class="p">)</span>
<span class="c1"># Another plot, to show the underlying line</span>
<span class="n">fine_y_sigmoid</span> <span class="o">=</span> <span class="n">params_to_predicted_probabilities</span><span class="p">(</span><span class="n">nice_intercept</span><span class="p">,</span> <span class="n">nice_slope</span><span class="p">,</span> <span class="n">fine_x</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fine_x</span><span class="p">,</span> <span class="n">fine_y_sigmoid</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> 
         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">params_to_predicted_probabilities</span><span class="p">(</span><span class="n">nice_intercept</span><span class="p">,</span> <span class="n">nice_slope</span><span class="p">,</span> <span class="mi">10</span><span class="p">)],</span> 
         <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> 
         <span class="p">[</span><span class="n">params_to_predicted_probabilities</span><span class="p">(</span><span class="n">nice_intercept</span><span class="p">,</span> <span class="n">nice_slope</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
          <span class="n">params_to_predicted_probabilities</span><span class="p">(</span><span class="n">nice_intercept</span><span class="p">,</span> <span class="n">nice_slope</span><span class="p">,</span> <span class="mi">10</span><span class="p">)],</span>
         <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
<span class="c1"># Show the legend.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/868d337200bdec92e9c65fe46b2e93000840dd5b9ef1cf364581accbf6bccf22.png" src="_images/868d337200bdec92e9c65fe46b2e93000840dd5b9ef1cf364581accbf6bccf22.png" />
</div>
</div>
<p>The sigmoid curve, which we get via logistic regression, is exploiting the fact that probabilities range between 0 and 1,
and that our outcome variable is also constrained to be either 0 or 1. This
means we can meaningfully show the prediction line (showing the predicted
probabilities) and the outcome variable scores (0 or 1) on the same plot. (We will come
on to the mechanics of the fitting process later in the page).</p>
<p>Because of these appealing features, let’s say we do want to use this kind of
sigmoid line to predict <code class="docutils literal notranslate"><span class="pre">appetite_d</span></code>.  So far, we have only asked <code class="docutils literal notranslate"><span class="pre">minimize</span></code>
to predict directly from a straight line - for example, in the <code class="docutils literal notranslate"><span class="pre">ss_any_line</span></code> function.</p>
<p>How can we get <code class="docutils literal notranslate"><span class="pre">minimize</span></code> to predict from a family of sigmoid curves, as here?</p>
<p>We’d like to keep the machinery here as familiar as possible. So, ideally we’d like
to send a slope and intercept pair to <code class="docutils literal notranslate"><span class="pre">minimize</span></code>. How might we do that for a sigmoid curve,
given that a slope and intercept denote a straight line, rather than a curve?</p>
<p>We would need a conversion to transform a sigmoid curve like the one here, with y values from 0 to 1,
into a straight line, where the y values can vary from large negative number to large
positive number. Doing such a conversion, so we have a slope and
intercept that <code class="docutils literal notranslate"><span class="pre">minimize</span></code> can work with easily.</p>
<p>Fortunately, our mathematician friends can assure us that we can in fact go from our sigmoid curve (ranging
between 0 and 1) to a straight line with unconstrained y values, in two fairly simple steps. The
next sections will cover those steps.  The two steps are:</p>
<ul class="simple">
<li><p>Convert the 0 or 1 <em>probability</em> predictions to
predictions of the <em>odds</em>.  The odds can vary from 0 to very
large positive number.</p></li>
<li><p>Apply the <em>logarithm</em> function to convert the 0-to-very-large-positive
odds predictions to <em>log</em> odds predictions, which can vary from
very large negative number to very large positive number.</p></li>
</ul>
<p>(Do not worry if these steps don’t make sense yet - we’ll go over them in more detail below).</p>
<p>These two transformations together are called the <em>log-odds</em> or
<a class="reference external" href="https://en.wikipedia.org/wiki/Logit">logit</a> transformation.  <em>Logistical
regression</em> is regression using the <em>logit</em> transform.  Applying the logit
transform converts the sigmoid curve to a straight line.</p>
<p>We will explain more about the two stages of the transform below, but for now, here are the two stages in action, shown graphically.</p>
<p>This is the original sigmoid curve above, with the predictions, in its own
plot:</p>
<div class="cell tag_remove-input docutils container">
<div class="cell_output docutils container">
<img alt="_images/fa6679bb36cf905d5b08f8c17d8ab544bdc1786fd18089b8db36e3838d28bd58.png" src="_images/fa6679bb36cf905d5b08f8c17d8ab544bdc1786fd18089b8db36e3838d28bd58.png" />
</div>
</div>
<p>Next we apply the conversion which converts probability to odds:</p>
<div class="cell tag_remove-input docutils container">
<div class="cell_output docutils container">
<img alt="_images/66de31384b9b889d3d6840a495cc5ae4d17066ebafa81cf6f755103d7b1e0336.png" src="_images/66de31384b9b889d3d6840a495cc5ae4d17066ebafa81cf6f755103d7b1e0336.png" />
</div>
</div>
<p>Notice that this is an <em>exponential</em> graph, where the y values increase more
and more steeply as the x values increase.  We can turn exponential lines like
this one into straight lines, using the <em>logarithm</em> function, the next stage of
the logit transformation:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># show the predictions on the log odds scale</span>
<span class="n">predictions_or_log</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">predictions_or</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">hemoglobin</span><span class="p">,</span> <span class="n">predictions_or_log</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gold&#39;</span><span class="p">)</span>
<span class="n">fine_y_or_log</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">fine_y_or</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fine_x</span><span class="p">,</span> <span class="n">fine_y_or_log</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Logit prediction&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Hemoglobin&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Log odds&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/b23954e907c94a008ff7752c0ebc7a77be8d55bed435b1b993c1220803a5686f.png" src="_images/b23954e907c94a008ff7752c0ebc7a77be8d55bed435b1b993c1220803a5686f.png" />
</div>
</div>
<p>We can do this conversion <em>in either direction</em>:</p>
<ul class="simple">
<li><p>straight line -&gt; sigmoid curve</p></li>
<li><p>sigmoid curve -&gt; straight line</p></li>
</ul>
<p><strong>This has the important consequence that</strong> we can get <code class="docutils literal notranslate"><span class="pre">minimize</span></code> to find us a straight line,
then we can use our conversion to go back to the sigmoid curve. The sigmoid curve is on the original scale
of the data, where the outcome variable ranges between 0 and 1. We can then calculate error values
from the sigmoid curve and the original data points.</p>
<p>Pause here and re-read the last paragraph again. It is very important to understand
<em>why</em> we are doing these transformations, in order to not get lost in the detail.
To reiterate these are the steps:</p>
<ul class="simple">
<li><p>we (or <code class="docutils literal notranslate"><span class="pre">minimize</span></code>) generate a straight line (via a slope/intercept pairing)</p></li>
<li><p>we transform this straight line into a sigmoid curve</p></li>
<li><p>we assess use a goodness-of-fit metric (like error scores) to assess the fit of the sigmoid curve</p></li>
<li><p>we repeat this process until we (or <code class="docutils literal notranslate"><span class="pre">minimize</span></code>) find the best-fitting sigmoid curve</p></li>
</ul>
<p>The next few sections go into more detail on the odds and logarithm transformation steps.</p>
</section>
<section id="probability-and-odds">
<h2>Probability and Odds<a class="headerlink" href="#probability-and-odds" title="Permalink to this heading">#</a></h2>
<p>Because logistic regression uses probability and odds, we will go over these
foundational concepts in this section.</p>
<p>Specifically, for logistic regression, in contrast to linear regression, we are interested in
predicting the <em>probability of an observation falling into a particular outcome
category</em> (0 or 1).</p>
<p>In our case <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">==</span> <span class="pre">poor</span> <span class="pre">appetite</span></code> and <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">==</span> <span class="pre">good</span> <span class="pre">appetite</span></code>.
So, we are interested in the probability of a patient having <code class="docutils literal notranslate"><span class="pre">good</span></code>
appetite, predicted from the patient’s <code class="docutils literal notranslate"><span class="pre">hemoglobin</span></code> score.</p>
<p>We can think of probability as the <em>proportion of times</em> we expect to see a
particular outcome.</p>
<p>For example, there are 139 patients with <code class="docutils literal notranslate"><span class="pre">good</span></code> appetite in this data frame,
and 158 patients in total.  If you were to repeatedly draw a single patient at
random from the data frame, and record their <code class="docutils literal notranslate"><span class="pre">appetite</span></code>, then we expect the proportion of “good” values in the long run, to be <span class="math notranslate nohighlight">\(\Large \frac{139}{158}\)</span> — which is about <span class="math notranslate nohighlight">\(0.88\)</span>.  That is the same as saying there is a probability of 0.88 of a randomly-drawn patient of having a <code class="docutils literal notranslate"><span class="pre">good</span></code> appetite.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># the probability of having a `good` appetite</span>
<span class="n">hgb_app</span><span class="p">[</span><span class="s1">&#39;appetite_dummy&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">hgb_app</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>appetite_dummy
1    0.879747
0    0.120253
Name: count, dtype: float64
</pre></div>
</div>
</div>
</div>
<p>Because the patient’s appetite can only be <code class="docutils literal notranslate"><span class="pre">good</span></code> or <code class="docutils literal notranslate"><span class="pre">poor</span></code>, and because the
probabilities of all possible options have to add up to 1, the probability of
the patient having a <code class="docutils literal notranslate"><span class="pre">poor</span></code> appetite is <span class="math notranslate nohighlight">\(1 - 0.88\)</span>, which is about <span class="math notranslate nohighlight">\(0.12\)</span>.</p>
<p>So, the probability can express the <em>proportion of times</em> we expect to see some
<em>event of interest</em> - in our case, the event of interest is “good” in the
<code class="docutils literal notranslate"><span class="pre">appetite</span></code> column:</p>
<p><span class="math notranslate nohighlight">\(\Large \text{probability} = \frac{\text{number of things of interest}}{\text{total number of things}}\)</span></p>
<p>We can think of this same information as an <em>odds</em>.</p>
<p>We often express probabilities as odds. To break this down, for clarity let’s think of a scenario with
some nice, clean probabilities.</p>
<p>Imagine there are 100 people standing in a room. 20 of them are civil servants. In this scenario, our <em>event of interest</em> is “being a civil servant”.
If we picked a person at random, the probability they will be a civil servant is:</p>
<p><span class="math notranslate nohighlight">\(\text{Prob(Civil Servant}) = \Large \frac{20}{100}\)</span>.</p>
<p>By contrast, the odds is the number of times we expect to see the event of interest
(e.g. being a civil servant) for every time we expect to see the event of no interest (NOT
being a civil servant):</p>
<p><span class="math notranslate nohighlight">\( \Large \text{odds} = \frac{\text{number of things of interest}}{\text{number of things NOT of interest}}\)</span></p>
<p>In the civil servant example, the <em>odds</em> of being a civil servant, if we pick a person at random, are:</p>
<p><span class="math notranslate nohighlight">\(\text{Odds(Civil Servant}) = \Large \frac{20}{80}\)</span>.</p>
<p>This is just a way of saying a probability in a different way, and we can convert easily between probabilities and odds.</p>
<p>To convert from a probability to an odds, we remember that the odds is the number of times we expect to see the event of interest for every time we expect to see the event of no interest.   This is the probability (proportion) for the event of interest, divided by the probability (proportion) of the event of NO interest.</p>
<p>We get the probability of events of no interest by subtracting the probability of an event of interest from 1.</p>
<p>Let’s look at the probability <span class="math notranslate nohighlight">\(p\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Our probability of interest </span>
<span class="n">p</span> <span class="o">=</span> <span class="mi">20</span><span class="o">/</span><span class="mi">100</span>
<span class="n">p</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.2
</pre></div>
</div>
</div>
</div>
<p>In mathematical notation:</p>
<p><span class="math notranslate nohighlight">\( \Large \text{probability} = \frac{\text{number of things of interest}}{\text{total number of things}} = \frac{20}{100} = 0.2\)</span></p>
<p>The equivalent odds here is:</p>
<p><span class="math notranslate nohighlight">\(\Large \text{odds} = \frac{\text{number of things of interest}}{\text{number of things NOT of interest}} = \frac{20}{80} = 0.25\)</span></p>
<p>We can also calculate the odds using this formula:</p>
<p><span class="math notranslate nohighlight">\(\Large \text{odds} = \frac{\text{Prob(Event of Interest)}}{1 - \text{Prob(Event of Interest)}}\)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># odds is proportion of interest, divided by proportion of no interest.</span>
<span class="n">odds</span> <span class="o">=</span> <span class="n">p</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span>
<span class="n">odds</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.25
</pre></div>
</div>
</div>
</div>
<p><span class="math notranslate nohighlight">\((1 - p)\)</span> gives the the probability of events which are not of interest (in this case, this is people who are NOT civil servants):</p>
<p><span class="math notranslate nohighlight">\(\text{Prob(Civil Servant}) = \Large \frac{20}{100}\)</span></p>
<p><span class="math notranslate nohighlight">\(\text{Prob(NOT Civil Servant}) = \Large \frac{80}{100}\)</span></p>
<p>Let’s demonstrate this in python:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">80</span><span class="o">/</span><span class="mi">100</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<p>When you are interpreting odds:</p>
<p><strong>Odds of 1 indicate that the event of interest is equally as likely as events NOT of interest.</strong></p>
<p><strong>Odds of less than one means that the event of interest is less likely to happen than
events NOT of interest.</strong>.</p>
<p><strong>Odds of greater than one means the event of interest is more likely to
happen than events NOT of interest.</strong></p>
<p><strong>If the probability of an event of interest is 0, then the odds are 0.</strong></p>
<p>You can use the slider in the output of the cell below to set the probability of a hypothetical event of interest.
(If you want a probability of 50%, set the slider to 50, if you want a probability of 30%, set the slider to 30 and so on).
The printout will then allow you to relate the probability to the odds of the event of interest:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">odds_interact</span><span class="p">(</span><span class="n">probability_percent</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>

    <span class="k">assert</span> <span class="p">(</span><span class="n">probability_percent</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">probability_percent</span> <span class="o">&lt;=</span><span class="mf">99.99</span><span class="p">),</span> <span class="s2">&quot;You must enter a percentage between 0 and 99.99!&quot;</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">probability_percent</span><span class="o">/</span><span class="mi">100</span>

    <span class="n">jupyprint</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;If a probability of an event of interest is **</span><span class="si">{</span><span class="n">probability_percent</span><span class="si">}</span><span class="s2">%**:&quot;</span><span class="p">)</span>
    <span class="n">jupyprint</span><span class="p">(</span><span class="s2">&quot;$</span><span class="se">\\</span><span class="s2">text{Prob(Event of Interest)} = </span><span class="se">\\</span><span class="s2">frac{&quot;</span><span class="o">+</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">probability_percent</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">+</span><span class="s2">&quot;}</span><span class="si">{100}</span><span class="s2">$&quot;</span><span class="p">)</span>
    <span class="n">jupyprint</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Then the odds of the event of interest are **</span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">p</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p</span><span class="p">),</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="si">}</span><span class="s2">**&quot;</span><span class="p">)</span>
    <span class="n">jupyprint</span><span class="p">(</span><span class="s2">&quot;$</span><span class="se">\\</span><span class="s2">text{Odds(Event of Interest)} = </span><span class="se">\\</span><span class="s2">frac{&quot;</span><span class="o">+</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">probability_percent</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">+</span><span class="s2">&quot;}{&quot;</span><span class="o">+</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mi">100</span><span class="o">-</span><span class="n">probability_percent</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">+</span><span class="s2">&quot;}$&quot;</span><span class="p">)</span>

<span class="n">interact</span><span class="p">(</span><span class="n">odds_interact</span><span class="p">,</span> <span class="n">probability_percent</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">{"version_major": 2, "version_minor": 0, "model_id": "e3b2b91e849a4395a766d4ec93bb7014"}</script><div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;function __main__.odds_interact(probability_percent=50)&gt;
</pre></div>
</div>
</div>
</div>
<p>As the probability of an event of interest gets very close to 1, the odds gets very large - this means the event of interest is many many times more likely than events of no interest:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">p_approaching_1</span> <span class="o">=</span> <span class="mf">0.9999999999999999</span>
<span class="n">large_odds</span> <span class="o">=</span> <span class="n">p_approaching_1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_approaching_1</span><span class="p">)</span>
<span class="n">large_odds</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>9007199254740991.0
</pre></div>
</div>
</div>
</div>
<p>Remember the example above where the probability of being a civil servant was
<span class="math notranslate nohighlight">\(\frac{20}{100}\)</span>? We can also convert from odds to probabilities.  Remember the odds is
the number of times we expect to see the event of interest, divided by the
number of times we expect to see the event of no interest.  The probability is
the proportion of events of interest out of all events.</p>
<p>We can convert back to the probability from the odds, using this formula:</p>
<p><span class="math notranslate nohighlight">\( \Large p = \frac{\text{odds}}{1 + \text{odds}} = \frac{0.25}{1.25} = 0.2 \)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># convert from odds to probability</span>
<span class="n">p_from_odds</span> <span class="o">=</span> <span class="n">odds</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">odds</span><span class="p">)</span>
<span class="n">p_from_odds</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.2
</pre></div>
</div>
</div>
</div>
<p>In summary here is that we can convert probabilities to odds with:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># convert from probability to odds</span>
<span class="n">odds</span> <span class="o">=</span> <span class="n">p</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span>
<span class="n">odds</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.25
</pre></div>
</div>
</div>
</div>
<p>And we can convert odds to probabilities with:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># convert odds to probabilities</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">odds</span> <span class="o">/</span> <span class="p">(</span><span class="n">odds</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">p</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.2
</pre></div>
</div>
</div>
</div>
<p>As you’ve seen, for the current data, and for sigmoid probability curve we showed you above, when we apply the conversion to convert the probability
values to odds, we get the following (this is the graphical perspective on the probability-to-odds transformation just shown above):</p>
<div class="cell tag_remove-input docutils container">
<div class="cell_output docutils container">
<img alt="_images/4c626bc71b34a3525e843e3ec95e77e7d5c4af0909fd2dc80200b80ac9579f56.png" src="_images/4c626bc71b34a3525e843e3ec95e77e7d5c4af0909fd2dc80200b80ac9579f56.png" />
</div>
</div>
<p>Notice that the odds we found vary from very close to 0 (for probability
predictions very close to 0) to very large (for probability
predictions very close to 1).</p>
<p>Notice too that our graph looks exponential, and we want it to be a straight
line (so we can pass a slope/intercept pair to <code class="docutils literal notranslate"><span class="pre">minimize</span></code>).</p>
<p>Our next step is to apply a <em>logarithm</em> transformation.</p>
</section>
<section id="the-logarithm-transform">
<h2>The logarithm transform<a class="headerlink" href="#the-logarithm-transform" title="Permalink to this heading">#</a></h2>
<p>See the <a class="reference external" href="https://lisds.github.io/textbook/more-regression/logarithms_refreshed">logarithm refresher</a> page for
more background on logarithms.</p>
<p>For now, <strong>the only thing you need to know about logarithms is that they are
transformations that convert an exponential curve into a straight line</strong>.</p>
<p>However, a very brief description is given just below. <em>We strongly recommend reading
the rest of the page first (skip to the next graph we show), and then come back
and read this brief explanation of logarithms</em>.</p>
<p>Essentially, a logarithm is an answer to the question “given a number, what power
would I have to raise a specific other number to, in order to get the first number?”.</p>
<p>So, let’s call that first number <span class="math notranslate nohighlight">\(a\)</span>, let’s raise it to the the power <span class="math notranslate nohighlight">\(n\)</span> and call the result
<span class="math notranslate nohighlight">\(y\)</span>:</p>
<p><span class="math notranslate nohighlight">\(\Large a^n = y\)</span></p>
<p>Here’s an example:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">a</span><span class="o">**</span><span class="n">n</span>
<span class="n">y</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>100
</pre></div>
</div>
</div>
</div>
<p>A logarithm tells us, given our value of <span class="math notranslate nohighlight">\(a\)</span>, what power would we have to raise <span class="math notranslate nohighlight">\(a\)</span> to, to get <span class="math notranslate nohighlight">\(y\)</span>?</p>
<p>We can write this as:</p>
<p><span class="math notranslate nohighlight">\(\Large \log_{a}(y) = n\)</span></p>
<p>You can read this as “if you give me the number <span class="math notranslate nohighlight">\(y\)</span>, what power would I have to raise the number <span class="math notranslate nohighlight">\(a\)</span> to, in order to get <span class="math notranslate nohighlight">\(y\)</span>?”.</p>
<p>As you can imagine, <code class="docutils literal notranslate"><span class="pre">numpy</span></code> functions exist to calculate logs:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2.0
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<p>The most important thing to understand is that logarithms transform an exponential graph into a straight line:</p>
<div class="cell tag_remove-input docutils container">
<div class="cell_output docutils container">
<img alt="_images/0e1130427eb2355ebcf4c4923227c3c2612c2322a19012b44bc8abeac4680244.png" src="_images/0e1130427eb2355ebcf4c4923227c3c2612c2322a19012b44bc8abeac4680244.png" />
</div>
</div>
<p>You have already see logs in action transforming the odds predictions.</p>
<div class="cell tag_remove-input docutils container">
<div class="cell_output docutils container">
<img alt="_images/907796754df6efbb22f22f414f82277102700c33364884502ddfcdc87ac441ca.png" src="_images/907796754df6efbb22f22f414f82277102700c33364884502ddfcdc87ac441ca.png" />
</div>
</div>
</section>
<section id="the-logit-transform-and-its-inverse">
<h2>The logit transform and its inverse<a class="headerlink" href="#the-logit-transform-and-its-inverse" title="Permalink to this heading">#</a></h2>
<p>The logit transformation from the sigmoid curve to the straight line consists
of two steps:</p>
<ul class="simple">
<li><p>Convert probability to odds.</p></li>
<li><p>Take the log of the result.</p></li>
</ul>
<p>The full logit transformation is therefore:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">logit</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Apply logit transformation to array of probabilities `p`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">odds</span> <span class="o">=</span> <span class="n">p</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">odds</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Here are the original sigmoid predictions and the predictions with the <code class="docutils literal notranslate"><span class="pre">logit</span></code> transform applied:</p>
<div class="cell tag_remove-input docutils container">
<div class="cell_output docutils container">
<img alt="_images/3bb6afbf5c246d7fd943c990230de9d552c26b2d6fc3c02ef77a4bec2e5414fa.png" src="_images/3bb6afbf5c246d7fd943c990230de9d552c26b2d6fc3c02ef77a4bec2e5414fa.png" />
</div>
</div>
<p>We also want to be able to go backwards, from the straight-line predictions, to
the sigmoid predictions.</p>
<p><code class="docutils literal notranslate"><span class="pre">np.exp</span></code> reverses (inverts) the <code class="docutils literal notranslate"><span class="pre">np.log</span></code> transformation (see the [logarithm
refresher]((<a class="reference external" href="https://lisds.github.io/textbook/more-regression/logarithms_refreshed">https://lisds.github.io/textbook/more-regression/logarithms_refreshed</a>)
page):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># np.exp reverses the effect of np.log.</span>
<span class="c1"># let&#39;s take some values...</span>
<span class="n">some_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">])</span>
<span class="n">some_values</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([1. , 0.5, 3. , 6. , 0.1])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># let&#39;s find the logarithm of these values...</span>
<span class="n">logged_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">some_values</span><span class="p">)</span>
<span class="n">logged_values</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([ 0.        , -0.69314718,  1.09861229,  1.79175947, -2.30258509])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># np.exp reverses the effect of np.log</span>
<span class="n">values_back</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">some_values</span><span class="p">))</span>
<span class="n">values_back</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([1. , 0.5, 3. , 6. , 0.1])
</pre></div>
</div>
</div>
</div>
<p>You have seen above that there is a simple formula to go from odds to
probabilities.  The transformation that <em>reverses</em>  (inverts) the logit
transform is therefore:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">inverse_logit</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Reverse logit transformation on array `v`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">odds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>  <span class="c1"># Reverse the log operation.</span>
    <span class="k">return</span> <span class="n">odds</span> <span class="o">/</span> <span class="p">(</span><span class="n">odds</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Reverse odds operation.</span>
</pre></div>
</div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">inverse_logit</span></code> takes points on a straight line, and converts them to points on a
sigmoid.</p>
<p>First we convince ourselves that <code class="docutils literal notranslate"><span class="pre">inverse_logit</span></code> does indeed reverse the <code class="docutils literal notranslate"><span class="pre">logit</span></code>
transform:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># some probability values</span>
<span class="n">some_p_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">])</span>
<span class="n">some_p_values</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([0.01, 0.05, 0.1 , 0.5 , 0.9 , 0.95, 0.99])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># we apply the logit transformation</span>
<span class="n">some_log_odds</span> <span class="o">=</span> <span class="n">logit</span><span class="p">(</span><span class="n">some_p_values</span><span class="p">)</span>
<span class="n">some_log_odds</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([-4.59511985, -2.94443898, -2.19722458,  0.        ,  2.19722458,
        2.94443898,  4.59511985])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># we use the inverse logit transformation to go back to the original values</span>
<span class="n">back_again</span> <span class="o">=</span> <span class="n">inverse_logit</span><span class="p">(</span><span class="n">some_log_odds</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Logit, then inverse_logit returns the original data:&#39;</span><span class="p">)</span>
<span class="n">back_again</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Logit, then inverse_logit returns the original data:
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([0.01, 0.05, 0.1 , 0.5 , 0.9 , 0.95, 0.99])
</pre></div>
</div>
</div>
</div>
<p>The plot above has the sigmoid curve p-value predictions, and the p-value
predictions with the logit transformation applied.</p>
<p>Next you see the logit-transformed results on the left.  The right shows the
results of applying <code class="docutils literal notranslate"><span class="pre">inverse_logit</span></code> to recover the original p values.</p>
<div class="cell tag_remove-input docutils container">
<div class="cell_output docutils container">
<img alt="_images/9fc6d44c028fe95e6257c9c27a139d10b2bc04726f5ce993d71fd4c48b5ffe29.png" src="_images/9fc6d44c028fe95e6257c9c27a139d10b2bc04726f5ce993d71fd4c48b5ffe29.png" />
</div>
</div>
<p>In summary here:</p>
<ul class="simple">
<li><p>the logit transformation converts probabilities to odds, then to log-odds</p></li>
<li><p>the inverse logit transformation converts log odds to odds, then to probabilities</p></li>
</ul>
<p>Let’s pause to recapitulate why we are covering these transformations:</p>
<ul class="simple">
<li><p>we are interested in modelling the probability of some binary categorical outcome, as a function of another variable</p></li>
<li><p>to do this, we’d like to pass a slope/intercept pair to <code class="docutils literal notranslate"><span class="pre">minimize</span></code>, but a straight line doesn’t
fit the binary categorical outcome variable very well</p></li>
</ul>
<p>So, to our solution here is:</p>
<ul class="simple">
<li><p>we (or <code class="docutils literal notranslate"><span class="pre">minimize</span></code>) generate a straight line (via a slope/intercept pairing)</p></li>
<li><p>we transform this straight line into a sigmoid curve (usinverse logit ing the transfrmations sh) above:</p></li>
<li><p>we assess use a goodness-of-fit metric (like error scores) to assess the fit of the sigmoid curve</p></li>
<li><p>we repeat this process until we (or <code class="docutils literal notranslate"><span class="pre">minimize</span></code>) find the best-fitting siegmoid curv</p></li>
</ul>
</section>
<section id="effect-of-the-logit-slope-and-intercept-on-the-sigmoid">
<h2>Effect of the Logit slope and intercept on the sigmoid<a class="headerlink" href="#effect-of-the-logit-slope-and-intercept-on-the-sigmoid" title="Permalink to this heading">#</a></h2>
<p>Let’s explore what effect specific slope/intercept values have on the shape
of the sigmoid curve.</p>
<p>Changing the intercept of the logit (log-odds) straight line moves the
corresponding inverse logit sigmoid curve left and right on the horizontal
axis:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">intercept</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">]:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fine_x</span><span class="p">,</span>
            <span class="n">params_to_predicted_probabilities</span><span class="p">(</span><span class="n">intercept</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="n">fine_x</span><span class="p">),</span>
            <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s1">&#39;logit intercept=</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">intercept</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Sigmoid probability predictions&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Hemoglobin&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Probability prediction&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/9433c129d2b10eb29b6bcb4ee3b53af7a8c3b45e7b66ef39fca3d908fb9a7059.png" src="_images/9433c129d2b10eb29b6bcb4ee3b53af7a8c3b45e7b66ef39fca3d908fb9a7059.png" />
</div>
</div>
<p>Changing the slope of the logit straight line makes the transition from 0 to 1
flatter or steeper:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">slope</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fine_x</span><span class="p">,</span>
            <span class="n">params_to_predicted_probabilities</span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="n">slope</span><span class="p">,</span> <span class="n">fine_x</span><span class="p">),</span>
            <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s1">&#39;logit slope=</span><span class="si">%.1f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">slope</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Sigmoid probability predictions&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Hemoglobin&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Probability prediction&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/1bb667248211d87e53221aa6029f7783c718cf9d92d6d7ca1b5c830887d57f36.png" src="_images/1bb667248211d87e53221aa6029f7783c718cf9d92d6d7ca1b5c830887d57f36.png" />
</div>
</div>
</section>
<section id="a-first-pass-at-logistic-regression">
<h2>A first-pass at logistic regression<a class="headerlink" href="#a-first-pass-at-logistic-regression" title="Permalink to this heading">#</a></h2>
<p>Hopefully now you can see how we can use <code class="docutils literal notranslate"><span class="pre">minimize</span></code>, with a slope and intercept pair,
to fit a sigmoid curve to a binary categorical outcome variable.</p>
<p>Remember that <code class="docutils literal notranslate"><span class="pre">minimize</span></code> needs a <em>cost function</em> that takes some parameters -
in our case, the intercept and slope — and returns a score, or cost for the
parameters.</p>
<p>In the <code class="docutils literal notranslate"><span class="pre">ss_any_line</span></code> cost function above, the score it returns is just the sum
of squared prediction errors from the line.  But the cost function can do
anything it likes to generate a score from the line or curve.</p>
<p>In our case, we’re going to make a cost function that:</p>
<ul class="simple">
<li><p>takes the intercept and slope, and generates predictions using the intercept and slope and <code class="docutils literal notranslate"><span class="pre">hemoglobin</span></code>
values.</p></li>
<li><p>the cost function then converts these predictions into probability
predictions, on a corresponding sigmoid curve, and compares these predictions to the 0 or 1 values
in <code class="docutils literal notranslate"><span class="pre">appetite_d</span></code>.</p></li>
</ul>
<p>For example, let’s say we want to get a score for the intercept -7 and the
slope 0.8.</p>
<p>First we get the straight-line predictions in the usual way:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">intercept</span><span class="p">,</span> <span class="n">slope</span> <span class="o">=</span> <span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="mf">0.8</span>
<span class="n">sl_predictions</span> <span class="o">=</span> <span class="n">intercept</span> <span class="o">+</span> <span class="n">slope</span> <span class="o">*</span> <span class="n">hemoglobin</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">hemoglobin</span><span class="p">,</span> <span class="n">sl_predictions</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;gold&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Hemoglobin&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Straight-line (log-odds) predictions&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/bbe8ee3741e6968509c368884162f4f86f7393f5e747dd2e734312f71de95884.png" src="_images/bbe8ee3741e6968509c368884162f4f86f7393f5e747dd2e734312f71de95884.png" />
</div>
</div>
<p>These are predictions on the straight line, but we now need to transform them
to p value (0 to 1) predictions on the sigmoid.  We use <code class="docutils literal notranslate"><span class="pre">inverse_logit</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sigmoid_predictions</span> <span class="o">=</span> <span class="n">inverse_logit</span><span class="p">(</span><span class="n">sl_predictions</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">hemoglobin</span><span class="p">,</span> <span class="n">sigmoid_predictions</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;gold&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Hemoglobin&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Sigmoid (probability) predictions&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/fa6d97b4099ea3b922182baaa76d0b2248366334ff6488ffaf3a02088dc543b8.png" src="_images/fa6d97b4099ea3b922182baaa76d0b2248366334ff6488ffaf3a02088dc543b8.png" />
</div>
</div>
<p>Finally, we want to compare the predictions to the actual data to get a score.
One way we could do this is our good old sum of the squared errors between the
sigmoid p-value predictions and the 0 or 1 values:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plot_hgb_app</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">hemoglobin</span><span class="p">,</span> <span class="n">sigmoid_predictions</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;gold&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;predictions from logit via sum of squares&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hemoglobin</span><span class="p">)):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">hemoglobin</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">hemoglobin</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="p">[</span><span class="n">sigmoid_predictions</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">appetite_d</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="s1">&#39;k:&#39;</span><span class="p">)</span>
<span class="c1"># the following code line is just to trick Matplotlib into making a new</span>
<span class="c1"># a single legend entry for the dotted lines.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([],</span> <span class="p">[],</span> <span class="s1">&#39;k:&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Errors ($ </span><span class="se">\\</span><span class="s1">varepsilon $)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Hemoglobin&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Sigmoid (p-value) predictions&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="p">(</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/0c84d87bafd40866c3f4bc972565550e4e2f33e944034749b7db1e897b0be40b.png" src="_images/0c84d87bafd40866c3f4bc972565550e4e2f33e944034749b7db1e897b0be40b.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sigmoid_error</span> <span class="o">=</span> <span class="n">appetite_d</span> <span class="o">-</span> <span class="n">sigmoid_predictions</span>
<span class="n">sigmoid_sum_squared_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sigmoid_error</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">sigmoid_sum_squared_error</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>10.044653157567184
</pre></div>
</div>
</div>
</div>
<p>Next we make the cost function that minimize will use.  It must accept an array
of parameters (an intercept and slope), and calculate the root mean squared error,
using the predicted probabilities:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">ss_logit</span><span class="p">(</span><span class="n">intercept_and_slope</span><span class="p">,</span> <span class="n">x_values</span><span class="p">,</span> <span class="n">y_values</span><span class="p">):</span>
    
    <span class="c1"># Unpack intercept and slope into values.</span>
    <span class="n">intercept</span><span class="p">,</span> <span class="n">slope</span> <span class="o">=</span> <span class="n">intercept_and_slope</span>
    
    <span class="c1"># Predicted values for log-odds straight line.</span>
    <span class="n">predicted_log_odds</span> <span class="o">=</span> <span class="n">intercept</span> <span class="o">+</span> <span class="n">slope</span> <span class="o">*</span> <span class="n">x_values</span>
    
    <span class="c1"># Convert the straight line predictions to a sigmoid probability curve.</span>
    <span class="n">predicted_probabilities</span> <span class="o">=</span> <span class="n">inverse_logit</span><span class="p">(</span><span class="n">predicted_log_odds</span><span class="p">)</span>
    
    <span class="c1"># Calculate the prediction errors.</span>
    <span class="n">sigmoid_error</span> <span class="o">=</span> <span class="n">y_values</span> <span class="o">-</span> <span class="n">predicted_probabilities</span>
    
    <span class="c1"># Root mean squared error</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sigmoid_error</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We check our function gives the same results as the step-by-step calculation above.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ss_logit</span><span class="p">([</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="n">hemoglobin</span><span class="p">,</span> <span class="n">appetite_d</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>10.044653157567184
</pre></div>
</div>
</div>
</div>
<p>Notice what is happening here.  The cost function gets the new intercept and
slope to try, makes the predictions from the intercept and slope, converts the
predictions to probabilities on the sigmoid, and tests those against the real
<code class="docutils literal notranslate"><span class="pre">appetite_d</span></code> values.</p>
<p>Now let’s see the cost function in action:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># use `minimize` to find the slope/intercept which give the minimum value of our cost function</span>
<span class="n">min_res_logit</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">ss_logit</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">hemoglobin</span><span class="p">,</span> <span class="n">appetite_d</span><span class="p">))</span>
<span class="n">min_res_logit</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>  message: Optimization terminated successfully.
  success: True
   status: 0
      fun: 9.62150413367661
        x: [-5.281e+00  5.849e-01]
      nit: 12
      jac: [ 2.384e-07  2.384e-07]
 hess_inv: [[ 6.276e+00 -5.944e-01]
            [-5.944e-01  5.886e-02]]
     nfev: 42
     njev: 14
</pre></div>
</div>
</div>
</div>
<p>Does this result look like it gives more convincing sigmoid predictions than
our guessed intercept an slope of -7 and 0.8?</p>
<p>First get the sigmoid predictions from this line:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">logit_ss_inter</span><span class="p">,</span> <span class="n">logit_ss_slope</span> <span class="o">=</span> <span class="n">min_res_logit</span><span class="o">.</span><span class="n">x</span>

<span class="n">jupyprint</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Intercept of best-fitting line on the log odds scale: **</span><span class="si">{</span><span class="n">logit_ss_inter</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s2">**&quot;</span><span class="p">)</span>
<span class="n">jupyprint</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Slope of best-fitting line on the log odds scale: **</span><span class="si">{</span><span class="n">logit_ss_slope</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s2">**&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<p>Intercept of best-fitting line on the log odds scale: <strong>-5.28</strong></p>
<p>Slope of best-fitting line on the log odds scale: <strong>0.58</strong></p>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Predicted values on log-odds straight line.</span>
<span class="n">predicted_log_odds</span> <span class="o">=</span> <span class="n">logit_ss_inter</span> <span class="o">+</span> <span class="n">logit_ss_slope</span> <span class="o">*</span> <span class="n">hemoglobin</span>

<span class="n">predicted_log_odds</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0      1.270421
1      0.276024
2      1.036445
3     -2.005241
4     -0.776868
         ...   
153    3.902650
154    4.370602
155    3.961144
156    3.025240
157    3.961144
Name: hemoglobin, Length: 158, dtype: float64
</pre></div>
</div>
</div>
</div>
<p>Then convert these log-odds (straight line) predictions to probabilities, using the inverse logit transformation:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Predicted p values on sigmoid.</span>
<span class="n">logit_ss_predicted_prob_of_1</span> <span class="o">=</span> <span class="n">inverse_logit</span><span class="p">(</span><span class="n">predicted_log_odds</span><span class="p">)</span>

<span class="n">logit_ss_predicted_prob_of_1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0      0.780815
1      0.568571
2      0.738164
3      0.118654
4      0.314995
         ...   
153    0.980211
154    0.987514
155    0.981314
156    0.953701
157    0.981314
Name: hemoglobin, Length: 158, dtype: float64
</pre></div>
</div>
</div>
</div>
<p>Then plot the predictions, from the best-fitting slope and intercept pair:</p>
<div class="cell tag_remove-input docutils container">
<div class="cell_output docutils container">
<img alt="_images/9da1b7285c4aadcab4eb341b63ec58f459ca6dad20aec5b86b3ea27ba747f3cd.png" src="_images/9da1b7285c4aadcab4eb341b63ec58f459ca6dad20aec5b86b3ea27ba747f3cd.png" />
</div>
</div>
</section>
<section id="a-different-measure-of-prediction-error">
<h2>A different measure of prediction error<a class="headerlink" href="#a-different-measure-of-prediction-error" title="Permalink to this heading">#</a></h2>
<p>Our sigmoid prediction from sum of squares above looks convincing enough, but,
is there a better way of scoring the predictions from our line, than sum of
squares? E.g. could we use a different cost function which would work better?</p>
<p>It turns out there is another quite different and very useful way to score the
predictions, called <em>likelihood</em>.  For reasons we discuss in <a class="reference external" href="https://lisds.github.io/textbook/more-regression/logistic_convexity">this
page</a>, all
standard implementations of logistic regression that we know of, use the
<em>likelihood</em> measure that we describe below, instead of the sum of squares
measure you see above.</p>
<p>Likelihood asks the question: assuming our predicting line, how likely  is the
sequence of actual 0 and 1 values that we see?</p>
<p>To answer this question, we first ask this question about the individual 0 and 1
values.</p>
<p>We start with our intercept of -7 and slope of 0.8 for the straight-line
log-odds values.  We generate the straight-line predictions, then convert them
to sigmoid probability predictions.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># generate our straight line predictions</span>
<span class="n">log_odds_predictions</span> <span class="o">=</span> <span class="o">-</span><span class="mi">7</span> <span class="o">+</span> <span class="n">hemoglobin</span> <span class="o">*</span> <span class="mf">0.8</span>

<span class="c1"># convert these to sigmoid probability predictions</span>
<span class="n">sigmoid_p_predictions</span> <span class="o">=</span> <span class="n">inverse_logit</span><span class="p">(</span><span class="n">log_odds_predictions</span><span class="p">)</span>

<span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;Log Odds Prediction&#39;</span><span class="p">:</span> <span class="n">log_odds_predictions</span><span class="p">,</span>
             <span class="s1">&#39;Probability Prediction&#39;</span><span class="p">:</span> <span class="n">sigmoid_p_predictions</span><span class="p">})</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Log Odds Prediction</th>
      <th>Probability Prediction</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1.96</td>
      <td>0.876533</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.60</td>
      <td>0.645656</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1.64</td>
      <td>0.837535</td>
    </tr>
    <tr>
      <th>3</th>
      <td>-2.52</td>
      <td>0.074468</td>
    </tr>
    <tr>
      <th>4</th>
      <td>-0.84</td>
      <td>0.301535</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>153</th>
      <td>5.56</td>
      <td>0.996166</td>
    </tr>
    <tr>
      <th>154</th>
      <td>6.20</td>
      <td>0.997975</td>
    </tr>
    <tr>
      <th>155</th>
      <td>5.64</td>
      <td>0.996460</td>
    </tr>
    <tr>
      <th>156</th>
      <td>4.36</td>
      <td>0.987383</td>
    </tr>
    <tr>
      <th>157</th>
      <td>5.64</td>
      <td>0.996460</td>
    </tr>
  </tbody>
</table>
<p>158 rows × 2 columns</p>
</div></div></div>
</div>
<p>Remember, the probability predictions are the predicted probabilities of <code class="docutils literal notranslate"><span class="pre">appetite_d</span> <span class="pre">==</span> <span class="pre">1</span></code>.
Let’s name the predictions appropriately to remind ourselves:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">predicted_prob_of_1</span> <span class="o">=</span> <span class="n">sigmoid_p_predictions</span>
</pre></div>
</div>
</div>
</div>
<p>We put these predictions into a copy of our data set to make them easier to display:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">hgb_predicted</span> <span class="o">=</span> <span class="n">hgb_app</span>
<span class="n">hgb_predicted</span><span class="p">[</span><span class="s1">&#39;predicted_prob_of_1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">predicted_prob_of_1</span>
<span class="n">hgb_predicted</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>hemoglobin</th>
      <th>appetite</th>
      <th>appetite_dummy</th>
      <th>predicted_prob_of_1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>11.2</td>
      <td>poor</td>
      <td>0</td>
      <td>0.876533</td>
    </tr>
    <tr>
      <th>1</th>
      <td>9.5</td>
      <td>poor</td>
      <td>0</td>
      <td>0.645656</td>
    </tr>
    <tr>
      <th>2</th>
      <td>10.8</td>
      <td>poor</td>
      <td>0</td>
      <td>0.837535</td>
    </tr>
    <tr>
      <th>3</th>
      <td>5.6</td>
      <td>poor</td>
      <td>0</td>
      <td>0.074468</td>
    </tr>
    <tr>
      <th>4</th>
      <td>7.7</td>
      <td>poor</td>
      <td>0</td>
      <td>0.301535</td>
    </tr>
    <tr>
      <th>5</th>
      <td>9.8</td>
      <td>good</td>
      <td>1</td>
      <td>0.698465</td>
    </tr>
    <tr>
      <th>6</th>
      <td>12.5</td>
      <td>good</td>
      <td>1</td>
      <td>0.952574</td>
    </tr>
    <tr>
      <th>7</th>
      <td>10.0</td>
      <td>good</td>
      <td>1</td>
      <td>0.731059</td>
    </tr>
    <tr>
      <th>8</th>
      <td>10.5</td>
      <td>good</td>
      <td>1</td>
      <td>0.802184</td>
    </tr>
    <tr>
      <th>9</th>
      <td>9.8</td>
      <td>good</td>
      <td>1</td>
      <td>0.698465</td>
    </tr>
    <tr>
      <th>10</th>
      <td>9.1</td>
      <td>good</td>
      <td>1</td>
      <td>0.569546</td>
    </tr>
    <tr>
      <th>11</th>
      <td>10.3</td>
      <td>good</td>
      <td>1</td>
      <td>0.775564</td>
    </tr>
    <tr>
      <th>12</th>
      <td>7.1</td>
      <td>poor</td>
      <td>0</td>
      <td>0.210818</td>
    </tr>
    <tr>
      <th>13</th>
      <td>13.0</td>
      <td>good</td>
      <td>1</td>
      <td>0.967705</td>
    </tr>
    <tr>
      <th>14</th>
      <td>16.1</td>
      <td>good</td>
      <td>1</td>
      <td>0.997213</td>
    </tr>
    <tr>
      <th>15</th>
      <td>10.4</td>
      <td>good</td>
      <td>1</td>
      <td>0.789182</td>
    </tr>
    <tr>
      <th>16</th>
      <td>9.2</td>
      <td>poor</td>
      <td>0</td>
      <td>0.589040</td>
    </tr>
    <tr>
      <th>17</th>
      <td>11.4</td>
      <td>poor</td>
      <td>0</td>
      <td>0.892832</td>
    </tr>
    <tr>
      <th>18</th>
      <td>8.1</td>
      <td>good</td>
      <td>1</td>
      <td>0.372852</td>
    </tr>
    <tr>
      <th>19</th>
      <td>8.2</td>
      <td>poor</td>
      <td>0</td>
      <td>0.391741</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Let’s look at a rown in the dataframe corresponding to an observational unit whose
actual <code class="docutils literal notranslate"><span class="pre">appetite_d</span></code> score was 1. We’ll use row number 5:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">observation_1</span> <span class="o">=</span> <span class="n">hgb_predicted</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
<span class="n">observation_1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>hemoglobin                  9.8
appetite                   good
appetite_dummy                1
predicted_prob_of_1    0.698465
Name: 5, dtype: object
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">predicted_prob_of_1</span></code> value is the probability that we will see a <code class="docutils literal notranslate"><span class="pre">appetite_d</span></code> score of 1 for this
observation.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">appetite_d</span></code> score for this observation was, in fact, 1.</p>
<p>Therefore the predicted probability that we will see the <em>actual <code class="docutils literal notranslate"><span class="pre">appetite_d</span></code> score is just the corresponding
<code class="docutils literal notranslate"><span class="pre">predicted_prob_of_1</span></code> value</em>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">predicted_prob_of_actual_score_obs_1</span> <span class="o">=</span> <span class="n">observation_1</span><span class="p">[</span><span class="s1">&#39;predicted_prob_of_1&#39;</span><span class="p">]</span>
<span class="n">predicted_prob_of_actual_score_obs_1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.698465216002539
</pre></div>
</div>
</div>
</div>
<p>Now consider an observational unit whose
actual <code class="docutils literal notranslate"><span class="pre">appetite_d</span></code> score was 0. We’ll use the observation in the first row of the dataframe:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">observation_2</span> <span class="o">=</span> <span class="n">hgb_predicted</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">observation_2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>hemoglobin                 11.2
appetite                   poor
appetite_dummy                0
predicted_prob_of_1    0.876533
Name: 0, dtype: object
</pre></div>
</div>
</div>
</div>
<p>The probability for an <code class="docutils literal notranslate"><span class="pre">appetite_dummy</span></code> value of 1, for this observation is:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">observation_2</span><span class="p">[</span><span class="s1">&#39;predicted_prob_of_1&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.876532952434776
</pre></div>
</div>
</div>
</div>
<p>However, <strong>and this is absolutely crucial</strong>: the actual <code class="docutils literal notranslate"><span class="pre">appetite_d</span></code> score of this observational unit
was 0.</p>
<p><em>Therefore the predicted probability of the <strong>actual</strong> score for this observational unit is <strong>NOT</strong> the predicted probability of a score of 1.</em></p>
<p>The actual score was 0, so we need to calculate the predicted probability of a score of 0.</p>
<p>You’ll remember that we can calculate the probability of the event NOT of interest by:</p>
<p><span class="math notranslate nohighlight">\(\text{Prob(Event NOT of Interest)} = 1 - \text{Prob(Event of Interest)}\)</span></p>
<p>Let’s do this for the current observational unit:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">predicted_prob_of_actual_score_obs_2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">observation_2</span><span class="p">[</span><span class="s1">&#39;predicted_prob_of_1&#39;</span><span class="p">]</span>
<span class="n">predicted_prob_of_actual_score_obs_2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.12346704756522398
</pre></div>
</div>
</div>
</div>
<p>We can therefore calculate the predicted probability of each observational unit’s <strong>actual</strong> score as follows.</p>
<p>We’ll do with a for loop to make it conceptually clearer what is happening:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># an empty array to store our predicted probability of getting the actual `appetite_d` score, for</span>
<span class="c1"># each observational unit</span>
<span class="n">predicted_prob_of_actual_score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hgb_predicted</span><span class="p">))</span>

<span class="c1"># loop over all the observations</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hgb_predicted</span><span class="p">)):</span>

    <span class="c1"># if the current observational unit (patient) had an `appetite_d` score of 1...</span>
    <span class="k">if</span> <span class="n">hgb_predicted</span><span class="p">[</span><span class="s1">&#39;appetite_dummy&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        
        <span class="c1"># ...then record the predicted probability of 1 as the predicted probability of its actual score</span>
        <span class="n">predicted_prob_of_actual_score</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hgb_predicted</span><span class="p">[</span><span class="s1">&#39;predicted_prob_of_1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="c1"># if the current observational unit (patient) had an `appetite_d` score of 0...</span>
    <span class="k">if</span> <span class="n">hgb_predicted</span><span class="p">[</span><span class="s1">&#39;appetite_dummy&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        
        <span class="c1"># ...then record `1 minus the predicted probability of 1` as the predicted probability of its actual score</span>
        <span class="n">predicted_prob_of_actual_score</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">hgb_predicted</span><span class="p">[</span><span class="s1">&#39;predicted_prob_of_1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
<span class="c1"># Put this into the data frame for display</span>
<span class="n">hgb_predicted</span><span class="p">[</span><span class="s1">&#39;predicted_prob_of_actual_score&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">predicted_prob_of_actual_score</span>
<span class="n">hgb_predicted</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>hemoglobin</th>
      <th>appetite</th>
      <th>appetite_dummy</th>
      <th>predicted_prob_of_1</th>
      <th>predicted_prob_of_actual_score</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>11.2</td>
      <td>poor</td>
      <td>0</td>
      <td>0.876533</td>
      <td>0.123467</td>
    </tr>
    <tr>
      <th>1</th>
      <td>9.5</td>
      <td>poor</td>
      <td>0</td>
      <td>0.645656</td>
      <td>0.354344</td>
    </tr>
    <tr>
      <th>2</th>
      <td>10.8</td>
      <td>poor</td>
      <td>0</td>
      <td>0.837535</td>
      <td>0.162465</td>
    </tr>
    <tr>
      <th>3</th>
      <td>5.6</td>
      <td>poor</td>
      <td>0</td>
      <td>0.074468</td>
      <td>0.925532</td>
    </tr>
    <tr>
      <th>4</th>
      <td>7.7</td>
      <td>poor</td>
      <td>0</td>
      <td>0.301535</td>
      <td>0.698465</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>153</th>
      <td>15.7</td>
      <td>good</td>
      <td>1</td>
      <td>0.996166</td>
      <td>0.996166</td>
    </tr>
    <tr>
      <th>154</th>
      <td>16.5</td>
      <td>good</td>
      <td>1</td>
      <td>0.997975</td>
      <td>0.997975</td>
    </tr>
    <tr>
      <th>155</th>
      <td>15.8</td>
      <td>good</td>
      <td>1</td>
      <td>0.996460</td>
      <td>0.996460</td>
    </tr>
    <tr>
      <th>156</th>
      <td>14.2</td>
      <td>good</td>
      <td>1</td>
      <td>0.987383</td>
      <td>0.987383</td>
    </tr>
    <tr>
      <th>157</th>
      <td>15.8</td>
      <td>good</td>
      <td>1</td>
      <td>0.996460</td>
      <td>0.996460</td>
    </tr>
  </tbody>
</table>
<p>158 rows × 5 columns</p>
</div></div></div>
</div>
<p>Go through each row of the dataframe above. Notice that for observational units (patients) who
have an <code class="docutils literal notranslate"><span class="pre">appetite_d</span></code> score of 1, the <code class="docutils literal notranslate"><span class="pre">predicted_prob_of_actual_score</span></code> just equals their
<code class="docutils literal notranslate"><span class="pre">predicted_prob_of_1</span></code>.</p>
<p>For observational units (patients) who have an <code class="docutils literal notranslate"><span class="pre">appetite_d</span></code> score of 0, the <code class="docutils literal notranslate"><span class="pre">predicted_prob_of_actual_score</span></code>
DOES NOT equal their  <code class="docutils literal notranslate"><span class="pre">predicted_prob_of_1</span></code>, it equals <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">predicted_prob_of_1</span></code>.</p>
<p><strong>This is critical for understanding logistic regression:</strong> for any slope/intercept pair we might use,
through the process just shown, we have a vector of probability predictions of the actual <code class="docutils literal notranslate"><span class="pre">appetite_d</span></code> score, for each observational unit.
We want all of these probabilities to be high e.g. we want the slope/intercept pair to give
good predictions of the actual scores. We can use this to compare how well different
slope/intercept pairs fit the data.</p>
<p><strong>Pause for Questions</strong>: let’s take a pause to make sure the process just shown is clear.</p>
<p>There’s a fancy short-cut to calculating the probabilities of the actual <code class="docutils literal notranslate"><span class="pre">appetite_d</span></code> scores.</p>
<p>We can create the <code class="docutils literal notranslate"><span class="pre">predicted_prob_of_actual_score</span></code> column by first
multiplying the 0 or 1 <code class="docutils literal notranslate"><span class="pre">appetite_d</span></code> scores by the values in <code class="docutils literal notranslate"><span class="pre">predicted_prob_of_1</span></code>.  This
correctly sets the <code class="docutils literal notranslate"><span class="pre">predicted_prob_of_actual_score</span></code> values for labels of 1, and leaves the
remainder as 0.</p>
<p>Then we reverse the 0 and 1 labels by subtracting from 1, and
multiply by <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">predicted_prob_of_1</span></code> to set the 0 values to their correct values.  Adding
these two results gives us the correct set of values for both 1 and 0 labels.</p>
<p>Let’s break this down:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># get the predicted probability of the actual `appetite_d` scores, for</span>
<span class="c1"># observations where `appetite_d == 1`</span>
<span class="n">probs_for_obs_with_good_appetite</span> <span class="o">=</span> <span class="n">appetite_d</span> <span class="o">*</span> <span class="n">predicted_prob_of_1</span>
<span class="n">probs_for_obs_with_good_appetite</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0      0.000000
1      0.000000
2      0.000000
3      0.000000
4      0.000000
         ...   
153    0.996166
154    0.997975
155    0.996460
156    0.987383
157    0.996460
Length: 158, dtype: float64
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># get the predicted probability of the actual `appetite_d` scores, for</span>
<span class="c1"># observations where `appetite_d == 0`</span>
<span class="n">probs_for_obs_with_bad_appetite</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">appetite_d</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">predicted_prob_of_1</span><span class="p">)</span>
<span class="n">probs_for_obs_with_bad_appetite</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0      0.123467
1      0.354344
2      0.162465
3      0.925532
4      0.698465
         ...   
153    0.000000
154    0.000000
155    0.000000
156    0.000000
157    0.000000
Length: 158, dtype: float64
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Combine by adding.</span>
<span class="n">final</span> <span class="o">=</span> <span class="n">probs_for_obs_with_good_appetite</span> <span class="o">+</span> <span class="n">probs_for_obs_with_bad_appetite</span> 

<span class="n">final</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0      0.123467
1      0.354344
2      0.162465
3      0.925532
4      0.698465
         ...   
153    0.996166
154    0.997975
155    0.996460
156    0.987383
157    0.996460
Length: 158, dtype: float64
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># This gives the same result as the code cell above:</span>
<span class="n">hgb_predicted</span><span class="p">[</span><span class="s1">&#39;predicted_prob_of_actual_score_fancy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">final</span>
<span class="n">hgb_predicted</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>hemoglobin</th>
      <th>appetite</th>
      <th>appetite_dummy</th>
      <th>predicted_prob_of_1</th>
      <th>predicted_prob_of_actual_score</th>
      <th>predicted_prob_of_actual_score_fancy</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>11.2</td>
      <td>poor</td>
      <td>0</td>
      <td>0.876533</td>
      <td>0.123467</td>
      <td>0.123467</td>
    </tr>
    <tr>
      <th>1</th>
      <td>9.5</td>
      <td>poor</td>
      <td>0</td>
      <td>0.645656</td>
      <td>0.354344</td>
      <td>0.354344</td>
    </tr>
    <tr>
      <th>2</th>
      <td>10.8</td>
      <td>poor</td>
      <td>0</td>
      <td>0.837535</td>
      <td>0.162465</td>
      <td>0.162465</td>
    </tr>
    <tr>
      <th>3</th>
      <td>5.6</td>
      <td>poor</td>
      <td>0</td>
      <td>0.074468</td>
      <td>0.925532</td>
      <td>0.925532</td>
    </tr>
    <tr>
      <th>4</th>
      <td>7.7</td>
      <td>poor</td>
      <td>0</td>
      <td>0.301535</td>
      <td>0.698465</td>
      <td>0.698465</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>153</th>
      <td>15.7</td>
      <td>good</td>
      <td>1</td>
      <td>0.996166</td>
      <td>0.996166</td>
      <td>0.996166</td>
    </tr>
    <tr>
      <th>154</th>
      <td>16.5</td>
      <td>good</td>
      <td>1</td>
      <td>0.997975</td>
      <td>0.997975</td>
      <td>0.997975</td>
    </tr>
    <tr>
      <th>155</th>
      <td>15.8</td>
      <td>good</td>
      <td>1</td>
      <td>0.996460</td>
      <td>0.996460</td>
      <td>0.996460</td>
    </tr>
    <tr>
      <th>156</th>
      <td>14.2</td>
      <td>good</td>
      <td>1</td>
      <td>0.987383</td>
      <td>0.987383</td>
      <td>0.987383</td>
    </tr>
    <tr>
      <th>157</th>
      <td>15.8</td>
      <td>good</td>
      <td>1</td>
      <td>0.996460</td>
      <td>0.996460</td>
      <td>0.996460</td>
    </tr>
  </tbody>
</table>
<p>158 rows × 6 columns</p>
</div></div></div>
</div>
<p>We can do the whole cell above in one line:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compact version of pp of label calculation.</span>
<span class="n">final_again</span> <span class="o">=</span> <span class="n">appetite_d</span> <span class="o">*</span> <span class="n">predicted_prob_of_1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">appetite_d</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">predicted_prob_of_1</span><span class="p">)</span>
<span class="n">hgb_predicted</span><span class="p">[</span><span class="s1">&#39;predicted_prob_of_actual_score_again&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_again</span>
<span class="n">hgb_predicted</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>hemoglobin</th>
      <th>appetite</th>
      <th>appetite_dummy</th>
      <th>predicted_prob_of_1</th>
      <th>predicted_prob_of_actual_score</th>
      <th>predicted_prob_of_actual_score_fancy</th>
      <th>predicted_prob_of_actual_score_again</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>11.2</td>
      <td>poor</td>
      <td>0</td>
      <td>0.876533</td>
      <td>0.123467</td>
      <td>0.123467</td>
      <td>0.123467</td>
    </tr>
    <tr>
      <th>1</th>
      <td>9.5</td>
      <td>poor</td>
      <td>0</td>
      <td>0.645656</td>
      <td>0.354344</td>
      <td>0.354344</td>
      <td>0.354344</td>
    </tr>
    <tr>
      <th>2</th>
      <td>10.8</td>
      <td>poor</td>
      <td>0</td>
      <td>0.837535</td>
      <td>0.162465</td>
      <td>0.162465</td>
      <td>0.162465</td>
    </tr>
    <tr>
      <th>3</th>
      <td>5.6</td>
      <td>poor</td>
      <td>0</td>
      <td>0.074468</td>
      <td>0.925532</td>
      <td>0.925532</td>
      <td>0.925532</td>
    </tr>
    <tr>
      <th>4</th>
      <td>7.7</td>
      <td>poor</td>
      <td>0</td>
      <td>0.301535</td>
      <td>0.698465</td>
      <td>0.698465</td>
      <td>0.698465</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>153</th>
      <td>15.7</td>
      <td>good</td>
      <td>1</td>
      <td>0.996166</td>
      <td>0.996166</td>
      <td>0.996166</td>
      <td>0.996166</td>
    </tr>
    <tr>
      <th>154</th>
      <td>16.5</td>
      <td>good</td>
      <td>1</td>
      <td>0.997975</td>
      <td>0.997975</td>
      <td>0.997975</td>
      <td>0.997975</td>
    </tr>
    <tr>
      <th>155</th>
      <td>15.8</td>
      <td>good</td>
      <td>1</td>
      <td>0.996460</td>
      <td>0.996460</td>
      <td>0.996460</td>
      <td>0.996460</td>
    </tr>
    <tr>
      <th>156</th>
      <td>14.2</td>
      <td>good</td>
      <td>1</td>
      <td>0.987383</td>
      <td>0.987383</td>
      <td>0.987383</td>
      <td>0.987383</td>
    </tr>
    <tr>
      <th>157</th>
      <td>15.8</td>
      <td>good</td>
      <td>1</td>
      <td>0.996460</td>
      <td>0.996460</td>
      <td>0.996460</td>
      <td>0.996460</td>
    </tr>
  </tbody>
</table>
<p>158 rows × 7 columns</p>
</div></div></div>
</div>
<p>When the <code class="docutils literal notranslate"><span class="pre">predicted_prob_of_actual_score</span></code> values are near 1, this means the result was close to
the prediction.  When they are near 0, it means the result was unlike the
prediction.</p>
<p>Now we know the probabilities of each actual 0 and 1 label, we can get a
measure of how <em>likely</em> the <em>combination</em> of all these labels are, given these
predictions. We do this by <em>multiplying</em> all the probabilities in
<code class="docutils literal notranslate"><span class="pre">predicted_prob_of_actual_score</span></code>.  When the probabilities in <code class="docutils literal notranslate"><span class="pre">predicted_prob_of_actual_score</span></code>
are all fairly near 1, multiplying them will give a number that is not very small.  When some or many
of the probabilities are close to 0, the multiplication will generate a very
small number.</p>
<p>The result of this multiplication is called the <em>likelihood</em> of this set of
labels, given the predictions.</p>
<p>If the predictions are closer to the actual values, the likelihood will be
larger, and closer to 1.  When the predictions are not close, the likelihood
will be low, and closer to 0.</p>
<p>Here is the likelihood for our intercept of -7 and slope of 0.8.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># np.prod multiplies each number to give the product of all the numbers.</span>
<span class="n">likelihood</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">hgb_predicted</span><span class="p">[</span><span class="s1">&#39;predicted_prob_of_actual_score&#39;</span><span class="p">])</span>
<span class="n">likelihood</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.463854029404182e-13
</pre></div>
</div>
</div>
</div>
<p>This is a very small number.  Likelihoods are often close to 0 with a
reasonable number of points, and somewhat inexact prediction, because there
tend to be a reasonable number of small p values in <code class="docutils literal notranslate"><span class="pre">predicted_prob_of_actual_score</span></code>.  The
question is - do other values for the intercept and slope give smaller or
larger values for the likelihood?</p>
<p>We can put this <em>likelihood</em> scoring into our cost function, instead of using
scoring with the sum of squares.</p>
<p>One wrinkle is that we want our cost function value to be <em>lower</em> when the
line is a good predictor, but the likelihood is <em>higher</em> when the line is a
good predictor. We solve this simply by sticking a minus on the likelihood
before we return from the cost function. This makes <code class="docutils literal notranslate"><span class="pre">minimize</span></code> find the
parameters giving the <em>minimum</em> of the <em>negative likelihood</em>, and therefore,
the <em>maximum likelihood</em> (ML).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">simple_ml_logit_cost</span><span class="p">(</span><span class="n">intercept_and_slope</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Simple version of cost function for maximum likelihood</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">intercept</span><span class="p">,</span> <span class="n">slope</span> <span class="o">=</span> <span class="n">intercept_and_slope</span>
    
    <span class="c1"># Make predictions on the log odds (straight line) scale</span>
    <span class="n">predicted_log_odds</span> <span class="o">=</span> <span class="n">intercept</span> <span class="o">+</span> <span class="n">slope</span> <span class="o">*</span> <span class="n">x</span>

    <span class="c1"># Convert these predictions to probabilities.</span>
    <span class="n">predicted_prob_of_1</span> <span class="o">=</span> <span class="n">inverse_logit</span><span class="p">(</span><span class="n">predicted_log_odds</span><span class="p">)</span>
    
    <span class="c1"># Calculate predicted probabilities of the actual scores (THIS IS THE MOST IMPORTANT STEP TO UNDERSTAND!)</span>
    <span class="n">predicted_prob_of_actual_scores</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">predicted_prob_of_1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">predicted_prob_of_1</span><span class="p">)</span>

    <span class="c1"># Multiply the predicted probabiity of the actual score</span>
    <span class="n">likelihood</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">predicted_prob_of_actual_scores</span><span class="p">)</span>
    
    <span class="c1"># Ask minimize to find maximum by adding minus sign.</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">likelihood</span>
</pre></div>
</div>
</div>
</div>
<p><strong>This is another key to understanding the logistic regression cost function:</strong></p>
<ul class="simple">
<li><p>we generate predicted probabilities of an outcome score of  (<code class="docutils literal notranslate"><span class="pre">appetite_d</span></code> == 1)1, based on a slope/intercept pair</p></li>
<li><p>we then calculate the predicted probability of each observational un’its <em>actual</em> score</p></li>
<li><p>we multiply the probabilities of the actual score together, giving us a <em>likeihood</em> value</p></li>
<li><p>the likelihood value is a metric of goodness-of-fit, like the sum of squared error</p></li>
<li><p>we find the slope/intercept pair that gives the best fitting sigmoid, measured via the likel</p></li>
<li><p>in practive we <code class="docutils literal notranslate"><span class="pre">minimize</span></code> the negative of the likelihoodihood</p></li>
</ul>
<p>We canour new that cost function, starting at our familiar intercept of -7 and
slope of 0.8.</p>
<p>Before we do, there is one extra wrinkle, that we will solve in another way
further down the notebook.  At the moment the likelihood values we are
returning are very small - in the order of <span class="math notranslate nohighlight">\(10^{-13}\)</span>.  We expect scores for
different plausible lines to differ from each other by an even smaller number.
By default, <code class="docutils literal notranslate"><span class="pre">minimize</span></code> will treat these very small differences as
insignificant.  We can tell <code class="docutils literal notranslate"><span class="pre">minimize</span></code> to pay attention to these tiny
differences by passing a very small value to the <code class="docutils literal notranslate"><span class="pre">tol</span></code> parameter (<code class="docutils literal notranslate"><span class="pre">tol</span></code> for
<em>tolerance</em>).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">logistic_reg_ML</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">simple_ml_logit_cost</span><span class="p">,</span>  <span class="c1"># Cost function</span>
                 <span class="p">[</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span>  <span class="c1"># Guessed intercept and slope</span>
                 <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">hemoglobin</span><span class="p">,</span> <span class="n">appetite_d</span><span class="p">),</span>  <span class="c1"># x and y values</span>
                 <span class="n">tol</span><span class="o">=</span><span class="mf">1e-16</span><span class="p">)</span>  <span class="c1"># Attend to tiny changes in cost function values.</span>
<span class="c1"># Show the result.</span>
<span class="n">logistic_reg_ML</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>  message: Desired error not necessarily achieved due to precision loss.
  success: False
   status: 2
      fun: -2.117164088219709e-13
        x: [-7.003e+00  7.722e-01]
      nit: 6
      jac: [ 2.279e-14 -2.254e-15]
 hess_inv: [[ 4.655e+07  4.707e+08]
            [ 4.707e+08  4.760e+09]]
     nfev: 166
     njev: 52
</pre></div>
</div>
</div>
</div>
<p>Let’s look at the predictions to see if they are reasonable.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># get the parameter estimates back from `minimize`</span>
<span class="n">inter_logistic_reg_ML</span><span class="p">,</span> <span class="n">slope_logistic_reg_ML</span> <span class="o">=</span> <span class="n">logistic_reg_ML</span><span class="o">.</span><span class="n">x</span>

<span class="c1"># generate probability predictions (predicting probability of `appetite_d == 1`)</span>
<span class="n">predicted_logistic_reg_ML</span> <span class="o">=</span> <span class="n">inverse_logit</span><span class="p">(</span><span class="n">inter_logistic_reg_ML</span> <span class="o">+</span> <span class="n">slope_logistic_reg_ML</span> <span class="o">*</span> <span class="n">hemoglobin</span><span class="p">)</span>

<span class="c1"># show the predictions</span>
<span class="n">predicted_logistic_reg_ML</span> 
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0      0.838301
1      0.582473
2      0.791958
3      0.064251
4      0.257886
         ...   
153    0.994062
154    0.996790
155    0.994501
156    0.981333
157    0.994501
Name: hemoglobin, Length: 158, dtype: float64
</pre></div>
</div>
</div>
</div>
<div class="cell tag_remove-input docutils container">
<div class="cell_output docutils container">
<img alt="_images/f96272a6c636270e43103a55c3a15236482f557fbad19471cb11c30ce433dc87.png" src="_images/f96272a6c636270e43103a55c3a15236482f557fbad19471cb11c30ce433dc87.png" />
</div>
</div>
</section>
<section id="a-computation-trick-for-the-likelihood">
<h2>A computation trick for the likelihood<a class="headerlink" href="#a-computation-trick-for-the-likelihood" title="Permalink to this heading">#</a></h2>
<p>As you have seen, the likelihood values can be, and often are, very small, and
close to zero.</p>
<p>You may also know that standard numerical calculations on computers are not
completely precise; the calculations are only accurate to around 16 decimal
places.  This is because of the way computers store floating point numbers.
You can find more detail in <a class="reference external" href="http://matthew-brett.github.io/teaching/floating_point.html">this page on floating point
numbers</a>.</p>
<p>The combination of small likelihood values, and limited calculation precision,
can be a problem for the simple ML logistic cost function you see above.  As a
result, practical implementations of logistic regression use an extra trick to
improve the calculation accuracy of the likelihoods.</p>
<p>This trick also involves logarithms.</p>
<p>Here we show a very important property of the logarithm transform:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Multiplying two numbers&#39;</span><span class="p">,</span> <span class="mi">11</span> <span class="o">*</span> <span class="mi">15</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Take logs, add logs, unlog&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">15</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Multiplying two numbers 165
Take logs, add logs, unlog 165.00000000000009
</pre></div>
</div>
</div>
</div>
<p>What you see here is that we get (almost) the same answer if we:</p>
<ul class="simple">
<li><p>Multiply two numbers OR</p></li>
<li><p>If we take the logs of the two numbers, <em>add them</em>, then reverse the log
operation, in this case with <code class="docutils literal notranslate"><span class="pre">np.exp</span></code>.</p></li>
</ul>
<p>We get <em>almost</em> the same number because of the limitations of the precision of
the calculations.  For our cases, we do not need to worry about these tiny
differences.</p>
<p>The log-add-unlog trick means that we can replace multiplication by addition,
if we take the logs of the values.</p>
<p>Here we do the same trick on an array of numbers:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">some_numbers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">11</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Product of the array&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">some_numbers</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Log-add-unlog on the array&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">some_numbers</span><span class="p">))))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Product of the array 49.5
Log-add-unlog on the array 49.500000000000036
</pre></div>
</div>
</div>
</div>
<p>We can use this same trick to calculate our likelihood by adding logs instead
of multiplying the probabilities directly:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Likelihood with product of array&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">hgb_predicted</span><span class="p">[</span><span class="s1">&#39;predicted_prob_of_actual_score&#39;</span><span class="p">]))</span>
<span class="c1"># The log-add-unlog version.</span>
<span class="n">logs_of_predicted_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">hgb_predicted</span><span class="p">[</span><span class="s1">&#39;predicted_prob_of_actual_score&#39;</span><span class="p">])</span>
<span class="n">log_likelihood</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">logs_of_predicted_prob</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Likelihood with log-add-unlog&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_likelihood</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Likelihood with product of array 1.463854029404182e-13
Likelihood with log-add-unlog 1.4638540294041883e-13
</pre></div>
</div>
</div>
</div>
<p>This doesn’t seem to have solved all our problem, because we still end up with
the type of tiny number that confuses <code class="docutils literal notranslate"><span class="pre">minimize</span></code>.</p>
<p>The next stage of the solution is to realize that the <code class="docutils literal notranslate"><span class="pre">minimize</span></code> does not need
the <em>actual likelihood</em>, it needs some number that goes <em>up or down in exactly
the same way as likelihood</em>.  If the cost function can return some number that
goes up when likelihood goes up, and goes down when likelihood goes down,
<code class="docutils literal notranslate"><span class="pre">minimize</span></code> will still find the same parameters to minimize this cost function.</p>
<p>Specifically we want the value that comes back from the cost function to vary
<a class="reference external" href="https://en.wikipedia.org/wiki/Monotonic_function">monotonically</a> with respect
to the likelihood.  See the discussion on monotonicity in the <a class="reference external" href="https://lisds.github.io/textbook//mean-slopes/sse_rmse">Sum of squares,
root mean square</a> page.</p>
<p>In our case you may be able to see that the likelihood and <em>log likelihood</em> are
monotonic with respect to each other, so if we find the parameters minimizing
log likelihood, those parameters will also minimize likelihood.</p>
<p>The plot below shows the monotonicity of likelihood and log likelihood.  You
can see it is true that when the likelihood goes up, then the log of the
likelihood will also go up, and vice versa, so the log the likelihood <em>is</em>
monotonic with respect to the likelihood, and we can use it instead of the
likelihood, in our cost function.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># show the relationship between the likelihood and log-likelihood</span>
<span class="n">likelihood_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">likelihood_values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">likelihood_values</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Likelihood&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Log likelihood&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/0fce5ec847372e6007e7aa8625ddd87a027024953b200c7d121e9cb79d4d1567.png" src="_images/0fce5ec847372e6007e7aa8625ddd87a027024953b200c7d121e9cb79d4d1567.png" />
</div>
</div>
<p>This means that our cost function does not have to do the last nasty unlog step
above, that generates the tiny value for likelihood.  We can just return the
(minus of the) log of the likelihood.  The log of the likelihood turns out to
be a manageable negative number, even when the resulting likelihood is tiny.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># the likelihood value from our guessed slope and intercept</span>
<span class="n">likelihood</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.463854029404182e-13
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># the log likelihood value, for the tiny likelihood above</span>
<span class="n">log_likelihood</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-29.552533505045645
</pre></div>
</div>
</div>
</div>
<p>This trick gives us a much more tractable number to return from the cost
function, because the log likelihood is much less affected by errors from lack
of precision in the calculation.</p>
<p>Let’s modify our cost function, so it is now safer/easier for <code class="docutils literal notranslate"><span class="pre">minimize</span></code> to work with:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mll_logit_cost</span><span class="p">(</span><span class="n">intercept_and_slope</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Cost function for maximum log likelihood</span>

<span class="sd">    Return minus of the log of the likelihood.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">intercept</span><span class="p">,</span> <span class="n">slope</span> <span class="o">=</span> <span class="n">intercept_and_slope</span>
    
    <span class="c1"># Make predictions for on the log odds (straight line) scale.</span>
    <span class="n">predicted_log_odds</span> <span class="o">=</span> <span class="n">intercept</span> <span class="o">+</span> <span class="n">slope</span> <span class="o">*</span> <span class="n">x</span>

    <span class="c1"># convert these predictions to sigmoid probability predictions</span>
    <span class="n">predicted_prob_of_1</span> <span class="o">=</span> <span class="n">inverse_logit</span><span class="p">(</span><span class="n">predicted_log_odds</span><span class="p">)</span>

    <span class="c1"># Calculate predicted probabilities of the actual score, for each observation.</span>
    <span class="n">predicted_probability_of_actual_score</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">predicted_prob_of_1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">predicted_prob_of_1</span><span class="p">)</span>
    
    <span class="c1"># Use logs to calculate log of the likelihood</span>
    <span class="n">log_likelihood</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">predicted_probability_of_actual_score</span><span class="p">))</span>
    
    <span class="c1"># Ask minimize to find maximum by adding minus sign.</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">log_likelihood</span>
</pre></div>
</div>
</div>
</div>
<p>Use the new cost function:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">logistic_reg_MLL</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">mll_logit_cost</span><span class="p">,</span>  <span class="c1"># Cost function</span>
                  <span class="p">[</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span>  <span class="c1"># Guessed intercept and slope</span>
                  <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">hemoglobin</span><span class="p">,</span> <span class="n">appetite_d</span><span class="p">),</span>  <span class="c1"># x and y values</span>
                  <span class="p">)</span>
<span class="c1"># Show the result.</span>
<span class="n">logistic_reg_MLL</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>  message: Optimization terminated successfully.
  success: True
   status: 0
      fun: 29.16799389585748
        x: [-7.292e+00  7.992e-01]
      nit: 7
      jac: [ 7.153e-07  0.000e+00]
 hess_inv: [[ 2.747e+00 -2.571e-01]
            [-2.571e-01  2.509e-02]]
     nfev: 27
     njev: 9
</pre></div>
</div>
</div>
</div>
<p>Notice that we did not have to tell <code class="docutils literal notranslate"><span class="pre">minimize</span></code> to use a very small value for
the tolerance this time.</p>
<p>The values that come back are very similar to our previous, more fragile
version that used the likelihood:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">inter_logistic_reg_MLL</span><span class="p">,</span> <span class="n">slope_logistic_reg_MLL</span> <span class="o">=</span> <span class="n">logistic_reg_MLL</span><span class="o">.</span><span class="n">x</span>
<span class="n">predicted_MLL</span> <span class="o">=</span> <span class="n">inverse_logit</span><span class="p">(</span><span class="n">inter_logistic_reg_MLL</span> <span class="o">+</span> <span class="n">slope_logistic_reg_MLL</span> <span class="o">*</span> <span class="n">hemoglobin</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_remove-input docutils container">
<div class="cell_output docutils container">
<img alt="_images/994a0d8962cd05cd1dac88a2aa91c570bd8b8c5d4efe76b69b75a8ed0a8fcf80.png" src="_images/994a0d8962cd05cd1dac88a2aa91c570bd8b8c5d4efe76b69b75a8ed0a8fcf80.png" />
</div>
</div>
<p>You have just seen the standard calculations behind most packages that
implement logistic regression.</p>
<p>To show this is standard, let us do the same regression in Statsmodels</p>
</section>
<section id="logistic-regression-with-statsmodes">
<h2>Logistic Regression with Statsmodes<a class="headerlink" href="#logistic-regression-with-statsmodes" title="Permalink to this heading">#</a></h2>
<p>As with linear regression, we can easily perform logistic regression using
Statsmodels.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get the formula interface for Statsmodels</span>
<span class="kn">import</span> <span class="nn">statsmodels.formula.api</span> <span class="k">as</span> <span class="nn">smf</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create the model.</span>
<span class="n">log_reg_mod</span> <span class="o">=</span> <span class="n">smf</span><span class="o">.</span><span class="n">logit</span><span class="p">(</span><span class="s1">&#39;appetite_dummy ~ hemoglobin&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">hgb_app</span><span class="p">)</span>
<span class="c1"># Fit it.</span>
<span class="n">fitted_log_reg_mod</span> <span class="o">=</span> <span class="n">log_reg_mod</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
<span class="n">fitted_log_reg_mod</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Optimization terminated successfully.
         Current function value: 0.184608
         Iterations 8
</pre></div>
</div>
<div class="output text_html"><table class="simpletable">
<caption>Logit Regression Results</caption>
<tr>
  <th>Dep. Variable:</th>    <td>appetite_dummy</td>  <th>  No. Observations:  </th>  <td>   158</td>  
</tr>
<tr>
  <th>Model:</th>                 <td>Logit</td>      <th>  Df Residuals:      </th>  <td>   156</td>  
</tr>
<tr>
  <th>Method:</th>                 <td>MLE</td>       <th>  Df Model:          </th>  <td>     1</td>  
</tr>
<tr>
  <th>Date:</th>            <td>Fri, 22 Mar 2024</td> <th>  Pseudo R-squ.:     </th>  <td>0.4976</td>  
</tr>
<tr>
  <th>Time:</th>                <td>13:21:41</td>     <th>  Log-Likelihood:    </th> <td> -29.168</td> 
</tr>
<tr>
  <th>converged:</th>             <td>True</td>       <th>  LL-Null:           </th> <td> -58.054</td> 
</tr>
<tr>
  <th>Covariance Type:</th>     <td>nonrobust</td>    <th>  LLR p-value:       </th> <td>2.944e-14</td>
</tr>
</table>
<table class="simpletable">
<tr>
       <td></td>         <th>coef</th>     <th>std err</th>      <th>z</th>      <th>P>|z|</th>  <th>[0.025</th>    <th>0.975]</th>  
</tr>
<tr>
  <th>Intercept</th>  <td>   -7.2919</td> <td>    1.659</td> <td>   -4.396</td> <td> 0.000</td> <td>  -10.543</td> <td>   -4.041</td>
</tr>
<tr>
  <th>hemoglobin</th> <td>    0.7992</td> <td>    0.158</td> <td>    5.042</td> <td> 0.000</td> <td>    0.489</td> <td>    1.110</td>
</tr>
</table></div></div>
</div>
<p>Notice that Statsmodels lists the “Model” as “Logit” and the “Method” as “MLE”
— Maximum Likelihood Estimation.</p>
<p>Look at the table above under ‘coef’. Compare the logistic regression intercept
and slope that Statsmodels found to the ones we got from <code class="docutils literal notranslate"><span class="pre">minimize</span></code> and the
maximum log likelihood (MLL) cost function.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">jupyprint</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Intercept from minimize = **</span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">inter_logistic_reg_MLL</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="si">}</span><span class="s1">**&#39;</span><span class="p">)</span>
<span class="n">jupyprint</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Slope from minimize = **</span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">slope_logistic_reg_MLL</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="si">}</span><span class="s1">**&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<p>Intercept from minimize = <strong>-7.292</strong></p>
<p>Slope from minimize = <strong>0.799</strong></p>
</div>
</div>
<p>Finally, we can use the <code class="docutils literal notranslate"><span class="pre">predict</span></code> method of Statsmodels to generate predicted
probabilities from the logistic regression model we have just fitted:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sm_predictions</span> <span class="o">=</span> <span class="n">fitted_log_reg_mod</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">hgb_app</span><span class="p">[</span><span class="s1">&#39;hemoglobin&#39;</span><span class="p">])</span>
<span class="n">sm_predictions</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0    0.840058
1    0.574466
2    0.792325
3    0.056433
4    0.242617
dtype: float64
</pre></div>
</div>
</div>
</div>
<p>Let us plot the predicted probabilities of having “good” appetite, from
Statsmodels:</p>
<div class="cell tag_remove-input docutils container">
<div class="cell_output docutils container">
<img alt="_images/08b088cd2ef62a2533a8cc59d029cf5c5e613ff05c00f27b5d03c8559bb1d884.png" src="_images/08b088cd2ef62a2533a8cc59d029cf5c5e613ff05c00f27b5d03c8559bb1d884.png" />
</div>
</div>
<p>We can see graphically that these predictions look identical to the ones we
obtained from minimize.</p>
<p>Let us see what the largest absolute difference between the predictions from
the two methods is:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">predicted_MLL</span> <span class="o">-</span> <span class="n">sm_predictions</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.2126886475560816e-07
</pre></div>
</div>
</div>
</div>
<p>That is very close to 0. The models are making almost identical predictions.</p>
</section>
<section id="the-meaning-of-the-parameters">
<h2>The meaning of the parameters<a class="headerlink" href="#the-meaning-of-the-parameters" title="Permalink to this heading">#</a></h2>
<p>The slope and intercept returned by logistic regression show us something the (kind of) the exact same thing
in logistic regression as they tell us in linear regression:</p>
<ul class="simple">
<li><p>the intercept tells us the predicted outcome variable score for an observational unit where the predictor score == 0</p></li>
<li><p>the slope tells us the expected change in the <em>log-odds</em> of an outcome variable score of 1, for a 1-unit chance in the predictor</p></li>
</ul>
<p>It’s not very intuitive to interpret the slope on the log-odds scale that it naturally comes to us on!
We can use <code class="docutils literal notranslate"><span class="pre">np.exp()</span></code> to convert the slope to the <em>odds scale</em>, so it has more intuitive meaning:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">slope_logistic_reg_MLL</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2.223659791598112
</pre></div>
</div>
</div>
</div>
<p>We interpret this as “the odds of <code class="docutils literal notranslate"><span class="pre">appetite_d</span> <span class="pre">==</span> <span class="pre">1</span></code> are multiplied byw2.2246for each 1-unit increase in the predictor.on</p>
</section>
<section id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this heading">#</a></h2>
<p>This tutorial has shown you how to do binary logistic regression with one numerical predictor variable.</p>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "lisds/dsip",
            ref: "main",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#dummy-variables">Dummy Variables</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#how-about-linear-regression">How about linear regression?</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#another-prediction-line">Another prediction line</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#probability-and-odds">Probability and Odds</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-logarithm-transform">The logarithm transform</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-logit-transform-and-its-inverse">The logit transform and its inverse</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#effect-of-the-logit-slope-and-intercept-on-the-sigmoid">Effect of the Logit slope and intercept on the sigmoid</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-first-pass-at-logistic-regression">A first-pass at logistic regression</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-different-measure-of-prediction-error">A different measure of prediction error</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-computation-trick-for-the-likelihood">A computation trick for the likelihood</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#logistic-regression-with-statsmodes">Logistic Regression with Statsmodes</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-meaning-of-the-parameters">The meaning of the parameters</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#summary">Summary</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Matthew Brett and Peter Rush
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>